// +build !ignore_autogenerated

/*
Copyright 2016 The Kubernetes Authors All rights reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// This file was autogenerated by deepcopy-gen. Do not edit it manually!

package v1beta3

import (
	api "k8s.io/kubernetes/pkg/api"
	resource "k8s.io/kubernetes/pkg/api/resource"
	unversioned "k8s.io/kubernetes/pkg/api/unversioned"
	conversion "k8s.io/kubernetes/pkg/conversion"
	runtime "k8s.io/kubernetes/pkg/runtime"
	intstr "k8s.io/kubernetes/pkg/util/intstr"
)

func init() {
	if err := api.Scheme.AddGeneratedDeepCopyFuncs(
		DeepCopy_v1beta3_AWSElasticBlockStoreVolumeSource,
		DeepCopy_v1beta3_Binding,
		DeepCopy_v1beta3_Capabilities,
		DeepCopy_v1beta3_CephFSVolumeSource,
		DeepCopy_v1beta3_CinderVolumeSource,
		DeepCopy_v1beta3_ComponentCondition,
		DeepCopy_v1beta3_ComponentStatus,
		DeepCopy_v1beta3_ComponentStatusList,
		DeepCopy_v1beta3_Container,
		DeepCopy_v1beta3_ContainerPort,
		DeepCopy_v1beta3_ContainerState,
		DeepCopy_v1beta3_ContainerStateRunning,
		DeepCopy_v1beta3_ContainerStateTerminated,
		DeepCopy_v1beta3_ContainerStateWaiting,
		DeepCopy_v1beta3_ContainerStatus,
		DeepCopy_v1beta3_DaemonEndpoint,
		DeepCopy_v1beta3_DeleteOptions,
		DeepCopy_v1beta3_DownwardAPIVolumeFile,
		DeepCopy_v1beta3_DownwardAPIVolumeSource,
		DeepCopy_v1beta3_EmptyDirVolumeSource,
		DeepCopy_v1beta3_EndpointAddress,
		DeepCopy_v1beta3_EndpointPort,
		DeepCopy_v1beta3_EndpointSubset,
		DeepCopy_v1beta3_Endpoints,
		DeepCopy_v1beta3_EndpointsList,
		DeepCopy_v1beta3_EnvVar,
		DeepCopy_v1beta3_EnvVarSource,
		DeepCopy_v1beta3_Event,
		DeepCopy_v1beta3_EventList,
		DeepCopy_v1beta3_EventSource,
		DeepCopy_v1beta3_ExecAction,
		DeepCopy_v1beta3_FCVolumeSource,
		DeepCopy_v1beta3_FSGroupStrategyOptions,
		DeepCopy_v1beta3_FlockerVolumeSource,
		DeepCopy_v1beta3_GCEPersistentDiskVolumeSource,
		DeepCopy_v1beta3_GitRepoVolumeSource,
		DeepCopy_v1beta3_GlusterfsVolumeSource,
		DeepCopy_v1beta3_HTTPGetAction,
		DeepCopy_v1beta3_Handler,
		DeepCopy_v1beta3_HostPathVolumeSource,
		DeepCopy_v1beta3_IDRange,
		DeepCopy_v1beta3_ISCSIVolumeSource,
		DeepCopy_v1beta3_Lifecycle,
		DeepCopy_v1beta3_LimitRange,
		DeepCopy_v1beta3_LimitRangeItem,
		DeepCopy_v1beta3_LimitRangeList,
		DeepCopy_v1beta3_LimitRangeSpec,
		DeepCopy_v1beta3_List,
		DeepCopy_v1beta3_ListMeta,
		DeepCopy_v1beta3_ListOptions,
		DeepCopy_v1beta3_LoadBalancerIngress,
		DeepCopy_v1beta3_LoadBalancerStatus,
		DeepCopy_v1beta3_LocalObjectReference,
		DeepCopy_v1beta3_MetadataFile,
		DeepCopy_v1beta3_MetadataVolumeSource,
		DeepCopy_v1beta3_NFSVolumeSource,
		DeepCopy_v1beta3_Namespace,
		DeepCopy_v1beta3_NamespaceList,
		DeepCopy_v1beta3_NamespaceSpec,
		DeepCopy_v1beta3_NamespaceStatus,
		DeepCopy_v1beta3_Node,
		DeepCopy_v1beta3_NodeAddress,
		DeepCopy_v1beta3_NodeCondition,
		DeepCopy_v1beta3_NodeDaemonEndpoints,
		DeepCopy_v1beta3_NodeList,
		DeepCopy_v1beta3_NodeSpec,
		DeepCopy_v1beta3_NodeStatus,
		DeepCopy_v1beta3_NodeSystemInfo,
		DeepCopy_v1beta3_ObjectFieldSelector,
		DeepCopy_v1beta3_ObjectMeta,
		DeepCopy_v1beta3_ObjectReference,
		DeepCopy_v1beta3_PersistentVolume,
		DeepCopy_v1beta3_PersistentVolumeClaim,
		DeepCopy_v1beta3_PersistentVolumeClaimList,
		DeepCopy_v1beta3_PersistentVolumeClaimSpec,
		DeepCopy_v1beta3_PersistentVolumeClaimStatus,
		DeepCopy_v1beta3_PersistentVolumeClaimVolumeSource,
		DeepCopy_v1beta3_PersistentVolumeList,
		DeepCopy_v1beta3_PersistentVolumeSource,
		DeepCopy_v1beta3_PersistentVolumeSpec,
		DeepCopy_v1beta3_PersistentVolumeStatus,
		DeepCopy_v1beta3_Pod,
		DeepCopy_v1beta3_PodAttachOptions,
		DeepCopy_v1beta3_PodCondition,
		DeepCopy_v1beta3_PodExecOptions,
		DeepCopy_v1beta3_PodList,
		DeepCopy_v1beta3_PodLogOptions,
		DeepCopy_v1beta3_PodProxyOptions,
		DeepCopy_v1beta3_PodSecurityContext,
		DeepCopy_v1beta3_PodSpec,
		DeepCopy_v1beta3_PodStatus,
		DeepCopy_v1beta3_PodStatusResult,
		DeepCopy_v1beta3_PodTemplate,
		DeepCopy_v1beta3_PodTemplateList,
		DeepCopy_v1beta3_PodTemplateSpec,
		DeepCopy_v1beta3_Probe,
		DeepCopy_v1beta3_RBDVolumeSource,
		DeepCopy_v1beta3_RangeAllocation,
		DeepCopy_v1beta3_ReplicationController,
		DeepCopy_v1beta3_ReplicationControllerList,
		DeepCopy_v1beta3_ReplicationControllerSpec,
		DeepCopy_v1beta3_ReplicationControllerStatus,
		DeepCopy_v1beta3_ResourceQuota,
		DeepCopy_v1beta3_ResourceQuotaList,
		DeepCopy_v1beta3_ResourceQuotaSpec,
		DeepCopy_v1beta3_ResourceQuotaStatus,
		DeepCopy_v1beta3_ResourceRequirements,
		DeepCopy_v1beta3_RunAsUserStrategyOptions,
		DeepCopy_v1beta3_SELinuxContextStrategyOptions,
		DeepCopy_v1beta3_SELinuxOptions,
		DeepCopy_v1beta3_Secret,
		DeepCopy_v1beta3_SecretList,
		DeepCopy_v1beta3_SecretVolumeSource,
		DeepCopy_v1beta3_SecurityContext,
		DeepCopy_v1beta3_SecurityContextConstraints,
		DeepCopy_v1beta3_SecurityContextConstraintsList,
		DeepCopy_v1beta3_SerializedReference,
		DeepCopy_v1beta3_Service,
		DeepCopy_v1beta3_ServiceAccount,
		DeepCopy_v1beta3_ServiceAccountList,
		DeepCopy_v1beta3_ServiceList,
		DeepCopy_v1beta3_ServicePort,
		DeepCopy_v1beta3_ServiceSpec,
		DeepCopy_v1beta3_ServiceStatus,
		DeepCopy_v1beta3_SupplementalGroupsStrategyOptions,
		DeepCopy_v1beta3_TCPSocketAction,
		DeepCopy_v1beta3_TypeMeta,
		DeepCopy_v1beta3_Volume,
		DeepCopy_v1beta3_VolumeMount,
		DeepCopy_v1beta3_VolumeSource,
	); err != nil {
		// if one of the deep copy functions is malformed, detect it immediately.
		panic(err)
	}
}

func DeepCopy_v1beta3_AWSElasticBlockStoreVolumeSource(in AWSElasticBlockStoreVolumeSource, out *AWSElasticBlockStoreVolumeSource, c *conversion.Cloner) error {
	out.VolumeID = in.VolumeID
	out.FSType = in.FSType
	out.Partition = in.Partition
	out.ReadOnly = in.ReadOnly
	return nil
}

func DeepCopy_v1beta3_Binding(in Binding, out *Binding, c *conversion.Cloner) error {
	if err := unversioned.DeepCopy_unversioned_TypeMeta(in.TypeMeta, &out.TypeMeta, c); err != nil {
		return err
	}
	if err := DeepCopy_v1beta3_ObjectMeta(in.ObjectMeta, &out.ObjectMeta, c); err != nil {
		return err
	}
	if err := DeepCopy_v1beta3_ObjectReference(in.Target, &out.Target, c); err != nil {
		return err
	}
	return nil
}

func DeepCopy_v1beta3_Capabilities(in Capabilities, out *Capabilities, c *conversion.Cloner) error {
	if in.Add != nil {
		in, out := in.Add, &out.Add
		*out = make([]Capability, len(in))
		for i := range in {
			(*out)[i] = in[i]
		}
	} else {
		out.Add = nil
	}
	if in.Drop != nil {
		in, out := in.Drop, &out.Drop
		*out = make([]Capability, len(in))
		for i := range in {
			(*out)[i] = in[i]
		}
	} else {
		out.Drop = nil
	}
	return nil
}

func DeepCopy_v1beta3_CephFSVolumeSource(in CephFSVolumeSource, out *CephFSVolumeSource, c *conversion.Cloner) error {
	if in.Monitors != nil {
		in, out := in.Monitors, &out.Monitors
		*out = make([]string, len(in))
		copy(*out, in)
	} else {
		out.Monitors = nil
	}
	out.User = in.User
	out.SecretFile = in.SecretFile
	if in.SecretRef != nil {
		in, out := in.SecretRef, &out.SecretRef
		*out = new(LocalObjectReference)
		if err := DeepCopy_v1beta3_LocalObjectReference(*in, *out, c); err != nil {
			return err
		}
	} else {
		out.SecretRef = nil
	}
	out.ReadOnly = in.ReadOnly
	return nil
}

func DeepCopy_v1beta3_CinderVolumeSource(in CinderVolumeSource, out *CinderVolumeSource, c *conversion.Cloner) error {
	out.VolumeID = in.VolumeID
	out.FSType = in.FSType
	out.ReadOnly = in.ReadOnly
	return nil
}

func DeepCopy_v1beta3_ComponentCondition(in ComponentCondition, out *ComponentCondition, c *conversion.Cloner) error {
	out.Type = in.Type
	out.Status = in.Status
	out.Message = in.Message
	out.Error = in.Error
	return nil
}

func DeepCopy_v1beta3_ComponentStatus(in ComponentStatus, out *ComponentStatus, c *conversion.Cloner) error {
	if err := unversioned.DeepCopy_unversioned_TypeMeta(in.TypeMeta, &out.TypeMeta, c); err != nil {
		return err
	}
	if err := DeepCopy_v1beta3_ObjectMeta(in.ObjectMeta, &out.ObjectMeta, c); err != nil {
		return err
	}
	if in.Conditions != nil {
		in, out := in.Conditions, &out.Conditions
		*out = make([]ComponentCondition, len(in))
		for i := range in {
			if err := DeepCopy_v1beta3_ComponentCondition(in[i], &(*out)[i], c); err != nil {
				return err
			}
		}
	} else {
		out.Conditions = nil
	}
	return nil
}

func DeepCopy_v1beta3_ComponentStatusList(in ComponentStatusList, out *ComponentStatusList, c *conversion.Cloner) error {
	if err := unversioned.DeepCopy_unversioned_TypeMeta(in.TypeMeta, &out.TypeMeta, c); err != nil {
		return err
	}
	if err := DeepCopy_v1beta3_ListMeta(in.ListMeta, &out.ListMeta, c); err != nil {
		return err
	}
	if in.Items != nil {
		in, out := in.Items, &out.Items
		*out = make([]ComponentStatus, len(in))
		for i := range in {
			if err := DeepCopy_v1beta3_ComponentStatus(in[i], &(*out)[i], c); err != nil {
				return err
			}
		}
	} else {
		out.Items = nil
	}
	return nil
}

func DeepCopy_v1beta3_Container(in Container, out *Container, c *conversion.Cloner) error {
	out.Name = in.Name
	out.Image = in.Image
	if in.Command != nil {
		in, out := in.Command, &out.Command
		*out = make([]string, len(in))
		copy(*out, in)
	} else {
		out.Command = nil
	}
	if in.Args != nil {
		in, out := in.Args, &out.Args
		*out = make([]string, len(in))
		copy(*out, in)
	} else {
		out.Args = nil
	}
	out.WorkingDir = in.WorkingDir
	if in.Ports != nil {
		in, out := in.Ports, &out.Ports
		*out = make([]ContainerPort, len(in))
		for i := range in {
			if err := DeepCopy_v1beta3_ContainerPort(in[i], &(*out)[i], c); err != nil {
				return err
			}
		}
	} else {
		out.Ports = nil
	}
	if in.Env != nil {
		in, out := in.Env, &out.Env
		*out = make([]EnvVar, len(in))
		for i := range in {
			if err := DeepCopy_v1beta3_EnvVar(in[i], &(*out)[i], c); err != nil {
				return err
			}
		}
	} else {
		out.Env = nil
	}
	if err := DeepCopy_v1beta3_ResourceRequirements(in.Resources, &out.Resources, c); err != nil {
		return err
	}
	if in.VolumeMounts != nil {
		in, out := in.VolumeMounts, &out.VolumeMounts
		*out = make([]VolumeMount, len(in))
		for i := range in {
			if err := DeepCopy_v1beta3_VolumeMount(in[i], &(*out)[i], c); err != nil {
				return err
			}
		}
	} else {
		out.VolumeMounts = nil
	}
	if in.LivenessProbe != nil {
		in, out := in.LivenessProbe, &out.LivenessProbe
		*out = new(Probe)
		if err := DeepCopy_v1beta3_Probe(*in, *out, c); err != nil {
			return err
		}
	} else {
		out.LivenessProbe = nil
	}
	if in.ReadinessProbe != nil {
		in, out := in.ReadinessProbe, &out.ReadinessProbe
		*out = new(Probe)
		if err := DeepCopy_v1beta3_Probe(*in, *out, c); err != nil {
			return err
		}
	} else {
		out.ReadinessProbe = nil
	}
	if in.Lifecycle != nil {
		in, out := in.Lifecycle, &out.Lifecycle
		*out = new(Lifecycle)
		if err := DeepCopy_v1beta3_Lifecycle(*in, *out, c); err != nil {
			return err
		}
	} else {
		out.Lifecycle = nil
	}
	out.TerminationMessagePath = in.TerminationMessagePath
	out.Privileged = in.Privileged
	out.ImagePullPolicy = in.ImagePullPolicy
	if err := DeepCopy_v1beta3_Capabilities(in.Capabilities, &out.Capabilities, c); err != nil {
		return err
	}
	if in.SecurityContext != nil {
		in, out := in.SecurityContext, &out.SecurityContext
		*out = new(SecurityContext)
		if err := DeepCopy_v1beta3_SecurityContext(*in, *out, c); err != nil {
			return err
		}
	} else {
		out.SecurityContext = nil
	}
	out.Stdin = in.Stdin
	out.StdinOnce = in.StdinOnce
	out.TTY = in.TTY
	return nil
}

func DeepCopy_v1beta3_ContainerPort(in ContainerPort, out *ContainerPort, c *conversion.Cloner) error {
	out.Name = in.Name
	out.HostPort = in.HostPort
	out.ContainerPort = in.ContainerPort
	out.Protocol = in.Protocol
	out.HostIP = in.HostIP
	return nil
}

func DeepCopy_v1beta3_ContainerState(in ContainerState, out *ContainerState, c *conversion.Cloner) error {
	if in.Waiting != nil {
		in, out := in.Waiting, &out.Waiting
		*out = new(ContainerStateWaiting)
		if err := DeepCopy_v1beta3_ContainerStateWaiting(*in, *out, c); err != nil {
			return err
		}
	} else {
		out.Waiting = nil
	}
	if in.Running != nil {
		in, out := in.Running, &out.Running
		*out = new(ContainerStateRunning)
		if err := DeepCopy_v1beta3_ContainerStateRunning(*in, *out, c); err != nil {
			return err
		}
	} else {
		out.Running = nil
	}
	if in.Termination != nil {
		in, out := in.Termination, &out.Termination
		*out = new(ContainerStateTerminated)
		if err := DeepCopy_v1beta3_ContainerStateTerminated(*in, *out, c); err != nil {
			return err
		}
	} else {
		out.Termination = nil
	}
	return nil
}

func DeepCopy_v1beta3_ContainerStateRunning(in ContainerStateRunning, out *ContainerStateRunning, c *conversion.Cloner) error {
	if err := unversioned.DeepCopy_unversioned_Time(in.StartedAt, &out.StartedAt, c); err != nil {
		return err
	}
	return nil
}

func DeepCopy_v1beta3_ContainerStateTerminated(in ContainerStateTerminated, out *ContainerStateTerminated, c *conversion.Cloner) error {
	out.ExitCode = in.ExitCode
	out.Signal = in.Signal
	out.Reason = in.Reason
	out.Message = in.Message
	if err := unversioned.DeepCopy_unversioned_Time(in.StartedAt, &out.StartedAt, c); err != nil {
		return err
	}
	if err := unversioned.DeepCopy_unversioned_Time(in.FinishedAt, &out.FinishedAt, c); err != nil {
		return err
	}
	out.ContainerID = in.ContainerID
	return nil
}

func DeepCopy_v1beta3_ContainerStateWaiting(in ContainerStateWaiting, out *ContainerStateWaiting, c *conversion.Cloner) error {
	out.Reason = in.Reason
	out.Message = in.Message
	return nil
}

func DeepCopy_v1beta3_ContainerStatus(in ContainerStatus, out *ContainerStatus, c *conversion.Cloner) error {
	out.Name = in.Name
	if err := DeepCopy_v1beta3_ContainerState(in.State, &out.State, c); err != nil {
		return err
	}
	if err := DeepCopy_v1beta3_ContainerState(in.LastTerminationState, &out.LastTerminationState, c); err != nil {
		return err
	}
	out.Ready = in.Ready
	out.RestartCount = in.RestartCount
	out.Image = in.Image
	out.ImageID = in.ImageID
	out.ContainerID = in.ContainerID
	return nil
}

func DeepCopy_v1beta3_DaemonEndpoint(in DaemonEndpoint, out *DaemonEndpoint, c *conversion.Cloner) error {
	out.Port = in.Port
	return nil
}

func DeepCopy_v1beta3_DeleteOptions(in DeleteOptions, out *DeleteOptions, c *conversion.Cloner) error {
	if err := unversioned.DeepCopy_unversioned_TypeMeta(in.TypeMeta, &out.TypeMeta, c); err != nil {
		return err
	}
	if in.GracePeriodSeconds != nil {
		in, out := in.GracePeriodSeconds, &out.GracePeriodSeconds
		*out = new(int64)
		**out = *in
	} else {
		out.GracePeriodSeconds = nil
	}
	return nil
}

func DeepCopy_v1beta3_DownwardAPIVolumeFile(in DownwardAPIVolumeFile, out *DownwardAPIVolumeFile, c *conversion.Cloner) error {
	out.Path = in.Path
	if err := DeepCopy_v1beta3_ObjectFieldSelector(in.FieldRef, &out.FieldRef, c); err != nil {
		return err
	}
	return nil
}

func DeepCopy_v1beta3_DownwardAPIVolumeSource(in DownwardAPIVolumeSource, out *DownwardAPIVolumeSource, c *conversion.Cloner) error {
	if in.Items != nil {
		in, out := in.Items, &out.Items
		*out = make([]DownwardAPIVolumeFile, len(in))
		for i := range in {
			if err := DeepCopy_v1beta3_DownwardAPIVolumeFile(in[i], &(*out)[i], c); err != nil {
				return err
			}
		}
	} else {
		out.Items = nil
	}
	return nil
}

func DeepCopy_v1beta3_EmptyDirVolumeSource(in EmptyDirVolumeSource, out *EmptyDirVolumeSource, c *conversion.Cloner) error {
	out.Medium = in.Medium
	return nil
}

func DeepCopy_v1beta3_EndpointAddress(in EndpointAddress, out *EndpointAddress, c *conversion.Cloner) error {
	out.IP = in.IP
	if in.TargetRef != nil {
		in, out := in.TargetRef, &out.TargetRef
		*out = new(ObjectReference)
		if err := DeepCopy_v1beta3_ObjectReference(*in, *out, c); err != nil {
			return err
		}
	} else {
		out.TargetRef = nil
	}
	return nil
}

func DeepCopy_v1beta3_EndpointPort(in EndpointPort, out *EndpointPort, c *conversion.Cloner) error {
	out.Name = in.Name
	out.Port = in.Port
	out.Protocol = in.Protocol
	return nil
}

func DeepCopy_v1beta3_EndpointSubset(in EndpointSubset, out *EndpointSubset, c *conversion.Cloner) error {
	if in.Addresses != nil {
		in, out := in.Addresses, &out.Addresses
		*out = make([]EndpointAddress, len(in))
		for i := range in {
			if err := DeepCopy_v1beta3_EndpointAddress(in[i], &(*out)[i], c); err != nil {
				return err
			}
		}
	} else {
		out.Addresses = nil
	}
	if in.NotReadyAddresses != nil {
		in, out := in.NotReadyAddresses, &out.NotReadyAddresses
		*out = make([]EndpointAddress, len(in))
		for i := range in {
			if err := DeepCopy_v1beta3_EndpointAddress(in[i], &(*out)[i], c); err != nil {
				return err
			}
		}
	} else {
		out.NotReadyAddresses = nil
	}
	if in.Ports != nil {
		in, out := in.Ports, &out.Ports
		*out = make([]EndpointPort, len(in))
		for i := range in {
			if err := DeepCopy_v1beta3_EndpointPort(in[i], &(*out)[i], c); err != nil {
				return err
			}
		}
	} else {
		out.Ports = nil
	}
	return nil
}

func DeepCopy_v1beta3_Endpoints(in Endpoints, out *Endpoints, c *conversion.Cloner) error {
	if err := unversioned.DeepCopy_unversioned_TypeMeta(in.TypeMeta, &out.TypeMeta, c); err != nil {
		return err
	}
	if err := DeepCopy_v1beta3_ObjectMeta(in.ObjectMeta, &out.ObjectMeta, c); err != nil {
		return err
	}
	if in.Subsets != nil {
		in, out := in.Subsets, &out.Subsets
		*out = make([]EndpointSubset, len(in))
		for i := range in {
			if err := DeepCopy_v1beta3_EndpointSubset(in[i], &(*out)[i], c); err != nil {
				return err
			}
		}
	} else {
		out.Subsets = nil
	}
	return nil
}

func DeepCopy_v1beta3_EndpointsList(in EndpointsList, out *EndpointsList, c *conversion.Cloner) error {
	if err := unversioned.DeepCopy_unversioned_TypeMeta(in.TypeMeta, &out.TypeMeta, c); err != nil {
		return err
	}
	if err := DeepCopy_v1beta3_ListMeta(in.ListMeta, &out.ListMeta, c); err != nil {
		return err
	}
	if in.Items != nil {
		in, out := in.Items, &out.Items
		*out = make([]Endpoints, len(in))
		for i := range in {
			if err := DeepCopy_v1beta3_Endpoints(in[i], &(*out)[i], c); err != nil {
				return err
			}
		}
	} else {
		out.Items = nil
	}
	return nil
}

func DeepCopy_v1beta3_EnvVar(in EnvVar, out *EnvVar, c *conversion.Cloner) error {
	out.Name = in.Name
	out.Value = in.Value
	if in.ValueFrom != nil {
		in, out := in.ValueFrom, &out.ValueFrom
		*out = new(EnvVarSource)
		if err := DeepCopy_v1beta3_EnvVarSource(*in, *out, c); err != nil {
			return err
		}
	} else {
		out.ValueFrom = nil
	}
	return nil
}

func DeepCopy_v1beta3_EnvVarSource(in EnvVarSource, out *EnvVarSource, c *conversion.Cloner) error {
	if in.FieldRef != nil {
		in, out := in.FieldRef, &out.FieldRef
		*out = new(ObjectFieldSelector)
		if err := DeepCopy_v1beta3_ObjectFieldSelector(*in, *out, c); err != nil {
			return err
		}
	} else {
		out.FieldRef = nil
	}
	return nil
}

func DeepCopy_v1beta3_Event(in Event, out *Event, c *conversion.Cloner) error {
	if err := unversioned.DeepCopy_unversioned_TypeMeta(in.TypeMeta, &out.TypeMeta, c); err != nil {
		return err
	}
	if err := DeepCopy_v1beta3_ObjectMeta(in.ObjectMeta, &out.ObjectMeta, c); err != nil {
		return err
	}
	if err := DeepCopy_v1beta3_ObjectReference(in.InvolvedObject, &out.InvolvedObject, c); err != nil {
		return err
	}
	out.Reason = in.Reason
	out.Message = in.Message
	if err := DeepCopy_v1beta3_EventSource(in.Source, &out.Source, c); err != nil {
		return err
	}
	if err := unversioned.DeepCopy_unversioned_Time(in.FirstTimestamp, &out.FirstTimestamp, c); err != nil {
		return err
	}
	if err := unversioned.DeepCopy_unversioned_Time(in.LastTimestamp, &out.LastTimestamp, c); err != nil {
		return err
	}
	out.Count = in.Count
	return nil
}

func DeepCopy_v1beta3_EventList(in EventList, out *EventList, c *conversion.Cloner) error {
	if err := unversioned.DeepCopy_unversioned_TypeMeta(in.TypeMeta, &out.TypeMeta, c); err != nil {
		return err
	}
	if err := DeepCopy_v1beta3_ListMeta(in.ListMeta, &out.ListMeta, c); err != nil {
		return err
	}
	if in.Items != nil {
		in, out := in.Items, &out.Items
		*out = make([]Event, len(in))
		for i := range in {
			if err := DeepCopy_v1beta3_Event(in[i], &(*out)[i], c); err != nil {
				return err
			}
		}
	} else {
		out.Items = nil
	}
	return nil
}

func DeepCopy_v1beta3_EventSource(in EventSource, out *EventSource, c *conversion.Cloner) error {
	out.Component = in.Component
	out.Host = in.Host
	return nil
}

func DeepCopy_v1beta3_ExecAction(in ExecAction, out *ExecAction, c *conversion.Cloner) error {
	if in.Command != nil {
		in, out := in.Command, &out.Command
		*out = make([]string, len(in))
		copy(*out, in)
	} else {
		out.Command = nil
	}
	return nil
}

func DeepCopy_v1beta3_FCVolumeSource(in FCVolumeSource, out *FCVolumeSource, c *conversion.Cloner) error {
	if in.TargetWWNs != nil {
		in, out := in.TargetWWNs, &out.TargetWWNs
		*out = make([]string, len(in))
		copy(*out, in)
	} else {
		out.TargetWWNs = nil
	}
	if in.Lun != nil {
		in, out := in.Lun, &out.Lun
		*out = new(int)
		**out = *in
	} else {
		out.Lun = nil
	}
	out.FSType = in.FSType
	out.ReadOnly = in.ReadOnly
	return nil
}

func DeepCopy_v1beta3_FSGroupStrategyOptions(in FSGroupStrategyOptions, out *FSGroupStrategyOptions, c *conversion.Cloner) error {
	out.Type = in.Type
	if in.Ranges != nil {
		in, out := in.Ranges, &out.Ranges
		*out = make([]IDRange, len(in))
		for i := range in {
			if err := DeepCopy_v1beta3_IDRange(in[i], &(*out)[i], c); err != nil {
				return err
			}
		}
	} else {
		out.Ranges = nil
	}
	return nil
}

func DeepCopy_v1beta3_FlockerVolumeSource(in FlockerVolumeSource, out *FlockerVolumeSource, c *conversion.Cloner) error {
	out.DatasetName = in.DatasetName
	return nil
}

func DeepCopy_v1beta3_GCEPersistentDiskVolumeSource(in GCEPersistentDiskVolumeSource, out *GCEPersistentDiskVolumeSource, c *conversion.Cloner) error {
	out.PDName = in.PDName
	out.FSType = in.FSType
	out.Partition = in.Partition
	out.ReadOnly = in.ReadOnly
	return nil
}

func DeepCopy_v1beta3_GitRepoVolumeSource(in GitRepoVolumeSource, out *GitRepoVolumeSource, c *conversion.Cloner) error {
	out.Repository = in.Repository
	out.Revision = in.Revision
	return nil
}

func DeepCopy_v1beta3_GlusterfsVolumeSource(in GlusterfsVolumeSource, out *GlusterfsVolumeSource, c *conversion.Cloner) error {
	out.EndpointsName = in.EndpointsName
	out.Path = in.Path
	out.ReadOnly = in.ReadOnly
	return nil
}

func DeepCopy_v1beta3_HTTPGetAction(in HTTPGetAction, out *HTTPGetAction, c *conversion.Cloner) error {
	out.Path = in.Path
	if err := intstr.DeepCopy_intstr_IntOrString(in.Port, &out.Port, c); err != nil {
		return err
	}
	out.Host = in.Host
	out.Scheme = in.Scheme
	return nil
}

func DeepCopy_v1beta3_Handler(in Handler, out *Handler, c *conversion.Cloner) error {
	if in.Exec != nil {
		in, out := in.Exec, &out.Exec
		*out = new(ExecAction)
		if err := DeepCopy_v1beta3_ExecAction(*in, *out, c); err != nil {
			return err
		}
	} else {
		out.Exec = nil
	}
	if in.HTTPGet != nil {
		in, out := in.HTTPGet, &out.HTTPGet
		*out = new(HTTPGetAction)
		if err := DeepCopy_v1beta3_HTTPGetAction(*in, *out, c); err != nil {
			return err
		}
	} else {
		out.HTTPGet = nil
	}
	if in.TCPSocket != nil {
		in, out := in.TCPSocket, &out.TCPSocket
		*out = new(TCPSocketAction)
		if err := DeepCopy_v1beta3_TCPSocketAction(*in, *out, c); err != nil {
			return err
		}
	} else {
		out.TCPSocket = nil
	}
	return nil
}

func DeepCopy_v1beta3_HostPathVolumeSource(in HostPathVolumeSource, out *HostPathVolumeSource, c *conversion.Cloner) error {
	out.Path = in.Path
	return nil
}

func DeepCopy_v1beta3_IDRange(in IDRange, out *IDRange, c *conversion.Cloner) error {
	out.Min = in.Min
	out.Max = in.Max
	return nil
}

func DeepCopy_v1beta3_ISCSIVolumeSource(in ISCSIVolumeSource, out *ISCSIVolumeSource, c *conversion.Cloner) error {
	out.TargetPortal = in.TargetPortal
	out.IQN = in.IQN
	out.Lun = in.Lun
	out.FSType = in.FSType
	out.ReadOnly = in.ReadOnly
	return nil
}

func DeepCopy_v1beta3_Lifecycle(in Lifecycle, out *Lifecycle, c *conversion.Cloner) error {
	if in.PostStart != nil {
		in, out := in.PostStart, &out.PostStart
		*out = new(Handler)
		if err := DeepCopy_v1beta3_Handler(*in, *out, c); err != nil {
			return err
		}
	} else {
		out.PostStart = nil
	}
	if in.PreStop != nil {
		in, out := in.PreStop, &out.PreStop
		*out = new(Handler)
		if err := DeepCopy_v1beta3_Handler(*in, *out, c); err != nil {
			return err
		}
	} else {
		out.PreStop = nil
	}
	return nil
}

func DeepCopy_v1beta3_LimitRange(in LimitRange, out *LimitRange, c *conversion.Cloner) error {
	if err := unversioned.DeepCopy_unversioned_TypeMeta(in.TypeMeta, &out.TypeMeta, c); err != nil {
		return err
	}
	if err := DeepCopy_v1beta3_ObjectMeta(in.ObjectMeta, &out.ObjectMeta, c); err != nil {
		return err
	}
	if err := DeepCopy_v1beta3_LimitRangeSpec(in.Spec, &out.Spec, c); err != nil {
		return err
	}
	return nil
}

func DeepCopy_v1beta3_LimitRangeItem(in LimitRangeItem, out *LimitRangeItem, c *conversion.Cloner) error {
	out.Type = in.Type
	if in.Max != nil {
		in, out := in.Max, &out.Max
		*out = make(ResourceList)
		for key, val := range in {
			newVal := new(resource.Quantity)
			if err := resource.DeepCopy_resource_Quantity(val, newVal, c); err != nil {
				return err
			}
			(*out)[key] = *newVal
		}
	} else {
		out.Max = nil
	}
	if in.Min != nil {
		in, out := in.Min, &out.Min
		*out = make(ResourceList)
		for key, val := range in {
			newVal := new(resource.Quantity)
			if err := resource.DeepCopy_resource_Quantity(val, newVal, c); err != nil {
				return err
			}
			(*out)[key] = *newVal
		}
	} else {
		out.Min = nil
	}
	if in.Default != nil {
		in, out := in.Default, &out.Default
		*out = make(ResourceList)
		for key, val := range in {
			newVal := new(resource.Quantity)
			if err := resource.DeepCopy_resource_Quantity(val, newVal, c); err != nil {
				return err
			}
			(*out)[key] = *newVal
		}
	} else {
		out.Default = nil
	}
	if in.DefaultRequest != nil {
		in, out := in.DefaultRequest, &out.DefaultRequest
		*out = make(ResourceList)
		for key, val := range in {
			newVal := new(resource.Quantity)
			if err := resource.DeepCopy_resource_Quantity(val, newVal, c); err != nil {
				return err
			}
			(*out)[key] = *newVal
		}
	} else {
		out.DefaultRequest = nil
	}
	if in.MaxLimitRequestRatio != nil {
		in, out := in.MaxLimitRequestRatio, &out.MaxLimitRequestRatio
		*out = make(ResourceList)
		for key, val := range in {
			newVal := new(resource.Quantity)
			if err := resource.DeepCopy_resource_Quantity(val, newVal, c); err != nil {
				return err
			}
			(*out)[key] = *newVal
		}
	} else {
		out.MaxLimitRequestRatio = nil
	}
	return nil
}

func DeepCopy_v1beta3_LimitRangeList(in LimitRangeList, out *LimitRangeList, c *conversion.Cloner) error {
	if err := unversioned.DeepCopy_unversioned_TypeMeta(in.TypeMeta, &out.TypeMeta, c); err != nil {
		return err
	}
	if err := DeepCopy_v1beta3_ListMeta(in.ListMeta, &out.ListMeta, c); err != nil {
		return err
	}
	if in.Items != nil {
		in, out := in.Items, &out.Items
		*out = make([]LimitRange, len(in))
		for i := range in {
			if err := DeepCopy_v1beta3_LimitRange(in[i], &(*out)[i], c); err != nil {
				return err
			}
		}
	} else {
		out.Items = nil
	}
	return nil
}

func DeepCopy_v1beta3_LimitRangeSpec(in LimitRangeSpec, out *LimitRangeSpec, c *conversion.Cloner) error {
	if in.Limits != nil {
		in, out := in.Limits, &out.Limits
		*out = make([]LimitRangeItem, len(in))
		for i := range in {
			if err := DeepCopy_v1beta3_LimitRangeItem(in[i], &(*out)[i], c); err != nil {
				return err
			}
		}
	} else {
		out.Limits = nil
	}
	return nil
}

func DeepCopy_v1beta3_List(in List, out *List, c *conversion.Cloner) error {
	if err := unversioned.DeepCopy_unversioned_TypeMeta(in.TypeMeta, &out.TypeMeta, c); err != nil {
		return err
	}
	if err := DeepCopy_v1beta3_ListMeta(in.ListMeta, &out.ListMeta, c); err != nil {
		return err
	}
	if in.Items != nil {
		in, out := in.Items, &out.Items
		*out = make([]runtime.RawExtension, len(in))
		for i := range in {
			if err := runtime.DeepCopy_runtime_RawExtension(in[i], &(*out)[i], c); err != nil {
				return err
			}
		}
	} else {
		out.Items = nil
	}
	return nil
}

func DeepCopy_v1beta3_ListMeta(in ListMeta, out *ListMeta, c *conversion.Cloner) error {
	out.SelfLink = in.SelfLink
	out.ResourceVersion = in.ResourceVersion
	return nil
}

func DeepCopy_v1beta3_ListOptions(in ListOptions, out *ListOptions, c *conversion.Cloner) error {
	if err := unversioned.DeepCopy_unversioned_TypeMeta(in.TypeMeta, &out.TypeMeta, c); err != nil {
		return err
	}
	out.LabelSelector = in.LabelSelector
	out.FieldSelector = in.FieldSelector
	out.Watch = in.Watch
	out.ResourceVersion = in.ResourceVersion
	return nil
}

func DeepCopy_v1beta3_LoadBalancerIngress(in LoadBalancerIngress, out *LoadBalancerIngress, c *conversion.Cloner) error {
	out.IP = in.IP
	out.Hostname = in.Hostname
	return nil
}

func DeepCopy_v1beta3_LoadBalancerStatus(in LoadBalancerStatus, out *LoadBalancerStatus, c *conversion.Cloner) error {
	if in.Ingress != nil {
		in, out := in.Ingress, &out.Ingress
		*out = make([]LoadBalancerIngress, len(in))
		for i := range in {
			if err := DeepCopy_v1beta3_LoadBalancerIngress(in[i], &(*out)[i], c); err != nil {
				return err
			}
		}
	} else {
		out.Ingress = nil
	}
	return nil
}

func DeepCopy_v1beta3_LocalObjectReference(in LocalObjectReference, out *LocalObjectReference, c *conversion.Cloner) error {
	out.Name = in.Name
	return nil
}

func DeepCopy_v1beta3_MetadataFile(in MetadataFile, out *MetadataFile, c *conversion.Cloner) error {
	out.Name = in.Name
	if err := DeepCopy_v1beta3_ObjectFieldSelector(in.FieldRef, &out.FieldRef, c); err != nil {
		return err
	}
	return nil
}

func DeepCopy_v1beta3_MetadataVolumeSource(in MetadataVolumeSource, out *MetadataVolumeSource, c *conversion.Cloner) error {
	if in.Items != nil {
		in, out := in.Items, &out.Items
		*out = make([]MetadataFile, len(in))
		for i := range in {
			if err := DeepCopy_v1beta3_MetadataFile(in[i], &(*out)[i], c); err != nil {
				return err
			}
		}
	} else {
		out.Items = nil
	}
	return nil
}

func DeepCopy_v1beta3_NFSVolumeSource(in NFSVolumeSource, out *NFSVolumeSource, c *conversion.Cloner) error {
	out.Server = in.Server
	out.Path = in.Path
	out.ReadOnly = in.ReadOnly
	return nil
}

func DeepCopy_v1beta3_Namespace(in Namespace, out *Namespace, c *conversion.Cloner) error {
	if err := unversioned.DeepCopy_unversioned_TypeMeta(in.TypeMeta, &out.TypeMeta, c); err != nil {
		return err
	}
	if err := DeepCopy_v1beta3_ObjectMeta(in.ObjectMeta, &out.ObjectMeta, c); err != nil {
		return err
	}
	if err := DeepCopy_v1beta3_NamespaceSpec(in.Spec, &out.Spec, c); err != nil {
		return err
	}
	if err := DeepCopy_v1beta3_NamespaceStatus(in.Status, &out.Status, c); err != nil {
		return err
	}
	return nil
}

func DeepCopy_v1beta3_NamespaceList(in NamespaceList, out *NamespaceList, c *conversion.Cloner) error {
	if err := unversioned.DeepCopy_unversioned_TypeMeta(in.TypeMeta, &out.TypeMeta, c); err != nil {
		return err
	}
	if err := DeepCopy_v1beta3_ListMeta(in.ListMeta, &out.ListMeta, c); err != nil {
		return err
	}
	if in.Items != nil {
		in, out := in.Items, &out.Items
		*out = make([]Namespace, len(in))
		for i := range in {
			if err := DeepCopy_v1beta3_Namespace(in[i], &(*out)[i], c); err != nil {
				return err
			}
		}
	} else {
		out.Items = nil
	}
	return nil
}

func DeepCopy_v1beta3_NamespaceSpec(in NamespaceSpec, out *NamespaceSpec, c *conversion.Cloner) error {
	if in.Finalizers != nil {
		in, out := in.Finalizers, &out.Finalizers
		*out = make([]FinalizerName, len(in))
		for i := range in {
			(*out)[i] = in[i]
		}
	} else {
		out.Finalizers = nil
	}
	return nil
}

func DeepCopy_v1beta3_NamespaceStatus(in NamespaceStatus, out *NamespaceStatus, c *conversion.Cloner) error {
	out.Phase = in.Phase
	return nil
}

func DeepCopy_v1beta3_Node(in Node, out *Node, c *conversion.Cloner) error {
	if err := unversioned.DeepCopy_unversioned_TypeMeta(in.TypeMeta, &out.TypeMeta, c); err != nil {
		return err
	}
	if err := DeepCopy_v1beta3_ObjectMeta(in.ObjectMeta, &out.ObjectMeta, c); err != nil {
		return err
	}
	if err := DeepCopy_v1beta3_NodeSpec(in.Spec, &out.Spec, c); err != nil {
		return err
	}
	if err := DeepCopy_v1beta3_NodeStatus(in.Status, &out.Status, c); err != nil {
		return err
	}
	return nil
}

func DeepCopy_v1beta3_NodeAddress(in NodeAddress, out *NodeAddress, c *conversion.Cloner) error {
	out.Type = in.Type
	out.Address = in.Address
	return nil
}

func DeepCopy_v1beta3_NodeCondition(in NodeCondition, out *NodeCondition, c *conversion.Cloner) error {
	out.Type = in.Type
	out.Status = in.Status
	if err := unversioned.DeepCopy_unversioned_Time(in.LastHeartbeatTime, &out.LastHeartbeatTime, c); err != nil {
		return err
	}
	if err := unversioned.DeepCopy_unversioned_Time(in.LastTransitionTime, &out.LastTransitionTime, c); err != nil {
		return err
	}
	out.Reason = in.Reason
	out.Message = in.Message
	return nil
}

func DeepCopy_v1beta3_NodeDaemonEndpoints(in NodeDaemonEndpoints, out *NodeDaemonEndpoints, c *conversion.Cloner) error {
	if err := DeepCopy_v1beta3_DaemonEndpoint(in.KubeletEndpoint, &out.KubeletEndpoint, c); err != nil {
		return err
	}
	return nil
}

func DeepCopy_v1beta3_NodeList(in NodeList, out *NodeList, c *conversion.Cloner) error {
	if err := unversioned.DeepCopy_unversioned_TypeMeta(in.TypeMeta, &out.TypeMeta, c); err != nil {
		return err
	}
	if err := DeepCopy_v1beta3_ListMeta(in.ListMeta, &out.ListMeta, c); err != nil {
		return err
	}
	if in.Items != nil {
		in, out := in.Items, &out.Items
		*out = make([]Node, len(in))
		for i := range in {
			if err := DeepCopy_v1beta3_Node(in[i], &(*out)[i], c); err != nil {
				return err
			}
		}
	} else {
		out.Items = nil
	}
	return nil
}

func DeepCopy_v1beta3_NodeSpec(in NodeSpec, out *NodeSpec, c *conversion.Cloner) error {
	out.PodCIDR = in.PodCIDR
	out.ExternalID = in.ExternalID
	out.ProviderID = in.ProviderID
	out.Unschedulable = in.Unschedulable
	return nil
}

func DeepCopy_v1beta3_NodeStatus(in NodeStatus, out *NodeStatus, c *conversion.Cloner) error {
	if in.Capacity != nil {
		in, out := in.Capacity, &out.Capacity
		*out = make(ResourceList)
		for key, val := range in {
			newVal := new(resource.Quantity)
			if err := resource.DeepCopy_resource_Quantity(val, newVal, c); err != nil {
				return err
			}
			(*out)[key] = *newVal
		}
	} else {
		out.Capacity = nil
	}
	out.Phase = in.Phase
	if in.Conditions != nil {
		in, out := in.Conditions, &out.Conditions
		*out = make([]NodeCondition, len(in))
		for i := range in {
			if err := DeepCopy_v1beta3_NodeCondition(in[i], &(*out)[i], c); err != nil {
				return err
			}
		}
	} else {
		out.Conditions = nil
	}
	if in.Addresses != nil {
		in, out := in.Addresses, &out.Addresses
		*out = make([]NodeAddress, len(in))
		for i := range in {
			if err := DeepCopy_v1beta3_NodeAddress(in[i], &(*out)[i], c); err != nil {
				return err
			}
		}
	} else {
		out.Addresses = nil
	}
	if err := DeepCopy_v1beta3_NodeDaemonEndpoints(in.DaemonEndpoints, &out.DaemonEndpoints, c); err != nil {
		return err
	}
	if err := DeepCopy_v1beta3_NodeSystemInfo(in.NodeInfo, &out.NodeInfo, c); err != nil {
		return err
	}
	return nil
}

func DeepCopy_v1beta3_NodeSystemInfo(in NodeSystemInfo, out *NodeSystemInfo, c *conversion.Cloner) error {
	out.MachineID = in.MachineID
	out.SystemUUID = in.SystemUUID
	out.BootID = in.BootID
	out.KernelVersion = in.KernelVersion
	out.OsImage = in.OsImage
	out.ContainerRuntimeVersion = in.ContainerRuntimeVersion
	out.KubeletVersion = in.KubeletVersion
	out.KubeProxyVersion = in.KubeProxyVersion
	return nil
}

func DeepCopy_v1beta3_ObjectFieldSelector(in ObjectFieldSelector, out *ObjectFieldSelector, c *conversion.Cloner) error {
	out.APIVersion = in.APIVersion
	out.FieldPath = in.FieldPath
	return nil
}

func DeepCopy_v1beta3_ObjectMeta(in ObjectMeta, out *ObjectMeta, c *conversion.Cloner) error {
	out.Name = in.Name
	out.GenerateName = in.GenerateName
	out.Namespace = in.Namespace
	out.SelfLink = in.SelfLink
	out.UID = in.UID
	out.ResourceVersion = in.ResourceVersion
	out.Generation = in.Generation
	if err := unversioned.DeepCopy_unversioned_Time(in.CreationTimestamp, &out.CreationTimestamp, c); err != nil {
		return err
	}
	if in.DeletionTimestamp != nil {
		in, out := in.DeletionTimestamp, &out.DeletionTimestamp
		*out = new(unversioned.Time)
		if err := unversioned.DeepCopy_unversioned_Time(*in, *out, c); err != nil {
			return err
		}
	} else {
		out.DeletionTimestamp = nil
	}
	if in.DeletionGracePeriodSeconds != nil {
		in, out := in.DeletionGracePeriodSeconds, &out.DeletionGracePeriodSeconds
		*out = new(int64)
		**out = *in
	} else {
		out.DeletionGracePeriodSeconds = nil
	}
	if in.Labels != nil {
		in, out := in.Labels, &out.Labels
		*out = make(map[string]string)
		for key, val := range in {
			(*out)[key] = val
		}
	} else {
		out.Labels = nil
	}
	if in.Annotations != nil {
		in, out := in.Annotations, &out.Annotations
		*out = make(map[string]string)
		for key, val := range in {
			(*out)[key] = val
		}
	} else {
		out.Annotations = nil
	}
	return nil
}

func DeepCopy_v1beta3_ObjectReference(in ObjectReference, out *ObjectReference, c *conversion.Cloner) error {
	out.Kind = in.Kind
	out.Namespace = in.Namespace
	out.Name = in.Name
	out.UID = in.UID
	out.APIVersion = in.APIVersion
	out.ResourceVersion = in.ResourceVersion
	out.FieldPath = in.FieldPath
	return nil
}

func DeepCopy_v1beta3_PersistentVolume(in PersistentVolume, out *PersistentVolume, c *conversion.Cloner) error {
	if err := unversioned.DeepCopy_unversioned_TypeMeta(in.TypeMeta, &out.TypeMeta, c); err != nil {
		return err
	}
	if err := DeepCopy_v1beta3_ObjectMeta(in.ObjectMeta, &out.ObjectMeta, c); err != nil {
		return err
	}
	if err := DeepCopy_v1beta3_PersistentVolumeSpec(in.Spec, &out.Spec, c); err != nil {
		return err
	}
	if err := DeepCopy_v1beta3_PersistentVolumeStatus(in.Status, &out.Status, c); err != nil {
		return err
	}
	return nil
}

func DeepCopy_v1beta3_PersistentVolumeClaim(in PersistentVolumeClaim, out *PersistentVolumeClaim, c *conversion.Cloner) error {
	if err := unversioned.DeepCopy_unversioned_TypeMeta(in.TypeMeta, &out.TypeMeta, c); err != nil {
		return err
	}
	if err := DeepCopy_v1beta3_ObjectMeta(in.ObjectMeta, &out.ObjectMeta, c); err != nil {
		return err
	}
	if err := DeepCopy_v1beta3_PersistentVolumeClaimSpec(in.Spec, &out.Spec, c); err != nil {
		return err
	}
	if err := DeepCopy_v1beta3_PersistentVolumeClaimStatus(in.Status, &out.Status, c); err != nil {
		return err
	}
	return nil
}

func DeepCopy_v1beta3_PersistentVolumeClaimList(in PersistentVolumeClaimList, out *PersistentVolumeClaimList, c *conversion.Cloner) error {
	if err := unversioned.DeepCopy_unversioned_TypeMeta(in.TypeMeta, &out.TypeMeta, c); err != nil {
		return err
	}
	if err := DeepCopy_v1beta3_ListMeta(in.ListMeta, &out.ListMeta, c); err != nil {
		return err
	}
	if in.Items != nil {
		in, out := in.Items, &out.Items
		*out = make([]PersistentVolumeClaim, len(in))
		for i := range in {
			if err := DeepCopy_v1beta3_PersistentVolumeClaim(in[i], &(*out)[i], c); err != nil {
				return err
			}
		}
	} else {
		out.Items = nil
	}
	return nil
}

func DeepCopy_v1beta3_PersistentVolumeClaimSpec(in PersistentVolumeClaimSpec, out *PersistentVolumeClaimSpec, c *conversion.Cloner) error {
	if in.AccessModes != nil {
		in, out := in.AccessModes, &out.AccessModes
		*out = make([]PersistentVolumeAccessMode, len(in))
		for i := range in {
			(*out)[i] = in[i]
		}
	} else {
		out.AccessModes = nil
	}
	if err := DeepCopy_v1beta3_ResourceRequirements(in.Resources, &out.Resources, c); err != nil {
		return err
	}
	out.VolumeName = in.VolumeName
	return nil
}

func DeepCopy_v1beta3_PersistentVolumeClaimStatus(in PersistentVolumeClaimStatus, out *PersistentVolumeClaimStatus, c *conversion.Cloner) error {
	out.Phase = in.Phase
	if in.AccessModes != nil {
		in, out := in.AccessModes, &out.AccessModes
		*out = make([]PersistentVolumeAccessMode, len(in))
		for i := range in {
			(*out)[i] = in[i]
		}
	} else {
		out.AccessModes = nil
	}
	if in.Capacity != nil {
		in, out := in.Capacity, &out.Capacity
		*out = make(ResourceList)
		for key, val := range in {
			newVal := new(resource.Quantity)
			if err := resource.DeepCopy_resource_Quantity(val, newVal, c); err != nil {
				return err
			}
			(*out)[key] = *newVal
		}
	} else {
		out.Capacity = nil
	}
	return nil
}

func DeepCopy_v1beta3_PersistentVolumeClaimVolumeSource(in PersistentVolumeClaimVolumeSource, out *PersistentVolumeClaimVolumeSource, c *conversion.Cloner) error {
	out.ClaimName = in.ClaimName
	out.ReadOnly = in.ReadOnly
	return nil
}

func DeepCopy_v1beta3_PersistentVolumeList(in PersistentVolumeList, out *PersistentVolumeList, c *conversion.Cloner) error {
	if err := unversioned.DeepCopy_unversioned_TypeMeta(in.TypeMeta, &out.TypeMeta, c); err != nil {
		return err
	}
	if err := DeepCopy_v1beta3_ListMeta(in.ListMeta, &out.ListMeta, c); err != nil {
		return err
	}
	if in.Items != nil {
		in, out := in.Items, &out.Items
		*out = make([]PersistentVolume, len(in))
		for i := range in {
			if err := DeepCopy_v1beta3_PersistentVolume(in[i], &(*out)[i], c); err != nil {
				return err
			}
		}
	} else {
		out.Items = nil
	}
	return nil
}

func DeepCopy_v1beta3_PersistentVolumeSource(in PersistentVolumeSource, out *PersistentVolumeSource, c *conversion.Cloner) error {
	if in.GCEPersistentDisk != nil {
		in, out := in.GCEPersistentDisk, &out.GCEPersistentDisk
		*out = new(GCEPersistentDiskVolumeSource)
		if err := DeepCopy_v1beta3_GCEPersistentDiskVolumeSource(*in, *out, c); err != nil {
			return err
		}
	} else {
		out.GCEPersistentDisk = nil
	}
	if in.AWSElasticBlockStore != nil {
		in, out := in.AWSElasticBlockStore, &out.AWSElasticBlockStore
		*out = new(AWSElasticBlockStoreVolumeSource)
		if err := DeepCopy_v1beta3_AWSElasticBlockStoreVolumeSource(*in, *out, c); err != nil {
			return err
		}
	} else {
		out.AWSElasticBlockStore = nil
	}
	if in.HostPath != nil {
		in, out := in.HostPath, &out.HostPath
		*out = new(HostPathVolumeSource)
		if err := DeepCopy_v1beta3_HostPathVolumeSource(*in, *out, c); err != nil {
			return err
		}
	} else {
		out.HostPath = nil
	}
	if in.Glusterfs != nil {
		in, out := in.Glusterfs, &out.Glusterfs
		*out = new(GlusterfsVolumeSource)
		if err := DeepCopy_v1beta3_GlusterfsVolumeSource(*in, *out, c); err != nil {
			return err
		}
	} else {
		out.Glusterfs = nil
	}
	if in.NFS != nil {
		in, out := in.NFS, &out.NFS
		*out = new(NFSVolumeSource)
		if err := DeepCopy_v1beta3_NFSVolumeSource(*in, *out, c); err != nil {
			return err
		}
	} else {
		out.NFS = nil
	}
	if in.RBD != nil {
		in, out := in.RBD, &out.RBD
		*out = new(RBDVolumeSource)
		if err := DeepCopy_v1beta3_RBDVolumeSource(*in, *out, c); err != nil {
			return err
		}
	} else {
		out.RBD = nil
	}
	if in.ISCSI != nil {
		in, out := in.ISCSI, &out.ISCSI
		*out = new(ISCSIVolumeSource)
		if err := DeepCopy_v1beta3_ISCSIVolumeSource(*in, *out, c); err != nil {
			return err
		}
	} else {
		out.ISCSI = nil
	}
	if in.CephFS != nil {
		in, out := in.CephFS, &out.CephFS
		*out = new(CephFSVolumeSource)
		if err := DeepCopy_v1beta3_CephFSVolumeSource(*in, *out, c); err != nil {
			return err
		}
	} else {
		out.CephFS = nil
	}
	if in.Cinder != nil {
		in, out := in.Cinder, &out.Cinder
		*out = new(CinderVolumeSource)
		if err := DeepCopy_v1beta3_CinderVolumeSource(*in, *out, c); err != nil {
			return err
		}
	} else {
		out.Cinder = nil
	}
	if in.FC != nil {
		in, out := in.FC, &out.FC
		*out = new(FCVolumeSource)
		if err := DeepCopy_v1beta3_FCVolumeSource(*in, *out, c); err != nil {
			return err
		}
	} else {
		out.FC = nil
	}
	if in.Flocker != nil {
		in, out := in.Flocker, &out.Flocker
		*out = new(FlockerVolumeSource)
		if err := DeepCopy_v1beta3_FlockerVolumeSource(*in, *out, c); err != nil {
			return err
		}
	} else {
		out.Flocker = nil
	}
	return nil
}

func DeepCopy_v1beta3_PersistentVolumeSpec(in PersistentVolumeSpec, out *PersistentVolumeSpec, c *conversion.Cloner) error {
	if in.Capacity != nil {
		in, out := in.Capacity, &out.Capacity
		*out = make(ResourceList)
		for key, val := range in {
			newVal := new(resource.Quantity)
			if err := resource.DeepCopy_resource_Quantity(val, newVal, c); err != nil {
				return err
			}
			(*out)[key] = *newVal
		}
	} else {
		out.Capacity = nil
	}
	if err := DeepCopy_v1beta3_PersistentVolumeSource(in.PersistentVolumeSource, &out.PersistentVolumeSource, c); err != nil {
		return err
	}
	if in.AccessModes != nil {
		in, out := in.AccessModes, &out.AccessModes
		*out = make([]PersistentVolumeAccessMode, len(in))
		for i := range in {
			(*out)[i] = in[i]
		}
	} else {
		out.AccessModes = nil
	}
	if in.ClaimRef != nil {
		in, out := in.ClaimRef, &out.ClaimRef
		*out = new(ObjectReference)
		if err := DeepCopy_v1beta3_ObjectReference(*in, *out, c); err != nil {
			return err
		}
	} else {
		out.ClaimRef = nil
	}
	out.PersistentVolumeReclaimPolicy = in.PersistentVolumeReclaimPolicy
	return nil
}

func DeepCopy_v1beta3_PersistentVolumeStatus(in PersistentVolumeStatus, out *PersistentVolumeStatus, c *conversion.Cloner) error {
	out.Phase = in.Phase
	out.Message = in.Message
	out.Reason = in.Reason
	return nil
}

func DeepCopy_v1beta3_Pod(in Pod, out *Pod, c *conversion.Cloner) error {
	if err := unversioned.DeepCopy_unversioned_TypeMeta(in.TypeMeta, &out.TypeMeta, c); err != nil {
		return err
	}
	if err := DeepCopy_v1beta3_ObjectMeta(in.ObjectMeta, &out.ObjectMeta, c); err != nil {
		return err
	}
	if err := DeepCopy_v1beta3_PodSpec(in.Spec, &out.Spec, c); err != nil {
		return err
	}
	if err := DeepCopy_v1beta3_PodStatus(in.Status, &out.Status, c); err != nil {
		return err
	}
	return nil
}

func DeepCopy_v1beta3_PodAttachOptions(in PodAttachOptions, out *PodAttachOptions, c *conversion.Cloner) error {
	if err := unversioned.DeepCopy_unversioned_TypeMeta(in.TypeMeta, &out.TypeMeta, c); err != nil {
		return err
	}
	out.Stdin = in.Stdin
	out.Stdout = in.Stdout
	out.Stderr = in.Stderr
	out.TTY = in.TTY
	out.Container = in.Container
	return nil
}

func DeepCopy_v1beta3_PodCondition(in PodCondition, out *PodCondition, c *conversion.Cloner) error {
	out.Type = in.Type
	out.Status = in.Status
	if err := unversioned.DeepCopy_unversioned_Time(in.LastProbeTime, &out.LastProbeTime, c); err != nil {
		return err
	}
	if err := unversioned.DeepCopy_unversioned_Time(in.LastTransitionTime, &out.LastTransitionTime, c); err != nil {
		return err
	}
	out.Reason = in.Reason
	out.Message = in.Message
	return nil
}

func DeepCopy_v1beta3_PodExecOptions(in PodExecOptions, out *PodExecOptions, c *conversion.Cloner) error {
	if err := unversioned.DeepCopy_unversioned_TypeMeta(in.TypeMeta, &out.TypeMeta, c); err != nil {
		return err
	}
	out.Stdin = in.Stdin
	out.Stdout = in.Stdout
	out.Stderr = in.Stderr
	out.TTY = in.TTY
	out.Container = in.Container
	if in.Command != nil {
		in, out := in.Command, &out.Command
		*out = make([]string, len(in))
		copy(*out, in)
	} else {
		out.Command = nil
	}
	return nil
}

func DeepCopy_v1beta3_PodList(in PodList, out *PodList, c *conversion.Cloner) error {
	if err := unversioned.DeepCopy_unversioned_TypeMeta(in.TypeMeta, &out.TypeMeta, c); err != nil {
		return err
	}
	if err := DeepCopy_v1beta3_ListMeta(in.ListMeta, &out.ListMeta, c); err != nil {
		return err
	}
	if in.Items != nil {
		in, out := in.Items, &out.Items
		*out = make([]Pod, len(in))
		for i := range in {
			if err := DeepCopy_v1beta3_Pod(in[i], &(*out)[i], c); err != nil {
				return err
			}
		}
	} else {
		out.Items = nil
	}
	return nil
}

func DeepCopy_v1beta3_PodLogOptions(in PodLogOptions, out *PodLogOptions, c *conversion.Cloner) error {
	if err := unversioned.DeepCopy_unversioned_TypeMeta(in.TypeMeta, &out.TypeMeta, c); err != nil {
		return err
	}
	out.Container = in.Container
	out.Follow = in.Follow
	out.Previous = in.Previous
	if in.SinceSeconds != nil {
		in, out := in.SinceSeconds, &out.SinceSeconds
		*out = new(int64)
		**out = *in
	} else {
		out.SinceSeconds = nil
	}
	if in.SinceTime != nil {
		in, out := in.SinceTime, &out.SinceTime
		*out = new(unversioned.Time)
		if err := unversioned.DeepCopy_unversioned_Time(*in, *out, c); err != nil {
			return err
		}
	} else {
		out.SinceTime = nil
	}
	out.Timestamps = in.Timestamps
	if in.TailLines != nil {
		in, out := in.TailLines, &out.TailLines
		*out = new(int64)
		**out = *in
	} else {
		out.TailLines = nil
	}
	if in.LimitBytes != nil {
		in, out := in.LimitBytes, &out.LimitBytes
		*out = new(int64)
		**out = *in
	} else {
		out.LimitBytes = nil
	}
	return nil
}

func DeepCopy_v1beta3_PodProxyOptions(in PodProxyOptions, out *PodProxyOptions, c *conversion.Cloner) error {
	if err := unversioned.DeepCopy_unversioned_TypeMeta(in.TypeMeta, &out.TypeMeta, c); err != nil {
		return err
	}
	out.Path = in.Path
	return nil
}

func DeepCopy_v1beta3_PodSecurityContext(in PodSecurityContext, out *PodSecurityContext, c *conversion.Cloner) error {
	if in.SELinuxOptions != nil {
		in, out := in.SELinuxOptions, &out.SELinuxOptions
		*out = new(SELinuxOptions)
		if err := DeepCopy_v1beta3_SELinuxOptions(*in, *out, c); err != nil {
			return err
		}
	} else {
		out.SELinuxOptions = nil
	}
	if in.RunAsUser != nil {
		in, out := in.RunAsUser, &out.RunAsUser
		*out = new(int64)
		**out = *in
	} else {
		out.RunAsUser = nil
	}
	if in.RunAsNonRoot != nil {
		in, out := in.RunAsNonRoot, &out.RunAsNonRoot
		*out = new(bool)
		**out = *in
	} else {
		out.RunAsNonRoot = nil
	}
	if in.SupplementalGroups != nil {
		in, out := in.SupplementalGroups, &out.SupplementalGroups
		*out = make([]int64, len(in))
		copy(*out, in)
	} else {
		out.SupplementalGroups = nil
	}
	if in.FSGroup != nil {
		in, out := in.FSGroup, &out.FSGroup
		*out = new(int64)
		**out = *in
	} else {
		out.FSGroup = nil
	}
	return nil
}

func DeepCopy_v1beta3_PodSpec(in PodSpec, out *PodSpec, c *conversion.Cloner) error {
	if in.Volumes != nil {
		in, out := in.Volumes, &out.Volumes
		*out = make([]Volume, len(in))
		for i := range in {
			if err := DeepCopy_v1beta3_Volume(in[i], &(*out)[i], c); err != nil {
				return err
			}
		}
	} else {
		out.Volumes = nil
	}
	if in.Containers != nil {
		in, out := in.Containers, &out.Containers
		*out = make([]Container, len(in))
		for i := range in {
			if err := DeepCopy_v1beta3_Container(in[i], &(*out)[i], c); err != nil {
				return err
			}
		}
	} else {
		out.Containers = nil
	}
	out.RestartPolicy = in.RestartPolicy
	if in.TerminationGracePeriodSeconds != nil {
		in, out := in.TerminationGracePeriodSeconds, &out.TerminationGracePeriodSeconds
		*out = new(int64)
		**out = *in
	} else {
		out.TerminationGracePeriodSeconds = nil
	}
	if in.ActiveDeadlineSeconds != nil {
		in, out := in.ActiveDeadlineSeconds, &out.ActiveDeadlineSeconds
		*out = new(int64)
		**out = *in
	} else {
		out.ActiveDeadlineSeconds = nil
	}
	out.DNSPolicy = in.DNSPolicy
	if in.NodeSelector != nil {
		in, out := in.NodeSelector, &out.NodeSelector
		*out = make(map[string]string)
		for key, val := range in {
			(*out)[key] = val
		}
	} else {
		out.NodeSelector = nil
	}
	out.ServiceAccount = in.ServiceAccount
	out.Host = in.Host
	out.HostNetwork = in.HostNetwork
	out.HostPID = in.HostPID
	out.HostIPC = in.HostIPC
	if in.SecurityContext != nil {
		in, out := in.SecurityContext, &out.SecurityContext
		*out = new(PodSecurityContext)
		if err := DeepCopy_v1beta3_PodSecurityContext(*in, *out, c); err != nil {
			return err
		}
	} else {
		out.SecurityContext = nil
	}
	if in.ImagePullSecrets != nil {
		in, out := in.ImagePullSecrets, &out.ImagePullSecrets
		*out = make([]LocalObjectReference, len(in))
		for i := range in {
			if err := DeepCopy_v1beta3_LocalObjectReference(in[i], &(*out)[i], c); err != nil {
				return err
			}
		}
	} else {
		out.ImagePullSecrets = nil
	}
	return nil
}

func DeepCopy_v1beta3_PodStatus(in PodStatus, out *PodStatus, c *conversion.Cloner) error {
	out.Phase = in.Phase
	if in.Conditions != nil {
		in, out := in.Conditions, &out.Conditions
		*out = make([]PodCondition, len(in))
		for i := range in {
			if err := DeepCopy_v1beta3_PodCondition(in[i], &(*out)[i], c); err != nil {
				return err
			}
		}
	} else {
		out.Conditions = nil
	}
	out.Message = in.Message
	out.Reason = in.Reason
	out.HostIP = in.HostIP
	out.PodIP = in.PodIP
	if in.StartTime != nil {
		in, out := in.StartTime, &out.StartTime
		*out = new(unversioned.Time)
		if err := unversioned.DeepCopy_unversioned_Time(*in, *out, c); err != nil {
			return err
		}
	} else {
		out.StartTime = nil
	}
	if in.ContainerStatuses != nil {
		in, out := in.ContainerStatuses, &out.ContainerStatuses
		*out = make([]ContainerStatus, len(in))
		for i := range in {
			if err := DeepCopy_v1beta3_ContainerStatus(in[i], &(*out)[i], c); err != nil {
				return err
			}
		}
	} else {
		out.ContainerStatuses = nil
	}
	return nil
}

func DeepCopy_v1beta3_PodStatusResult(in PodStatusResult, out *PodStatusResult, c *conversion.Cloner) error {
	if err := unversioned.DeepCopy_unversioned_TypeMeta(in.TypeMeta, &out.TypeMeta, c); err != nil {
		return err
	}
	if err := DeepCopy_v1beta3_ObjectMeta(in.ObjectMeta, &out.ObjectMeta, c); err != nil {
		return err
	}
	if err := DeepCopy_v1beta3_PodStatus(in.Status, &out.Status, c); err != nil {
		return err
	}
	return nil
}

func DeepCopy_v1beta3_PodTemplate(in PodTemplate, out *PodTemplate, c *conversion.Cloner) error {
	if err := unversioned.DeepCopy_unversioned_TypeMeta(in.TypeMeta, &out.TypeMeta, c); err != nil {
		return err
	}
	if err := DeepCopy_v1beta3_ObjectMeta(in.ObjectMeta, &out.ObjectMeta, c); err != nil {
		return err
	}
	if err := DeepCopy_v1beta3_PodTemplateSpec(in.Template, &out.Template, c); err != nil {
		return err
	}
	return nil
}

func DeepCopy_v1beta3_PodTemplateList(in PodTemplateList, out *PodTemplateList, c *conversion.Cloner) error {
	if err := unversioned.DeepCopy_unversioned_TypeMeta(in.TypeMeta, &out.TypeMeta, c); err != nil {
		return err
	}
	if err := DeepCopy_v1beta3_ListMeta(in.ListMeta, &out.ListMeta, c); err != nil {
		return err
	}
	if in.Items != nil {
		in, out := in.Items, &out.Items
		*out = make([]PodTemplate, len(in))
		for i := range in {
			if err := DeepCopy_v1beta3_PodTemplate(in[i], &(*out)[i], c); err != nil {
				return err
			}
		}
	} else {
		out.Items = nil
	}
	return nil
}

func DeepCopy_v1beta3_PodTemplateSpec(in PodTemplateSpec, out *PodTemplateSpec, c *conversion.Cloner) error {
	if err := DeepCopy_v1beta3_ObjectMeta(in.ObjectMeta, &out.ObjectMeta, c); err != nil {
		return err
	}
	if err := DeepCopy_v1beta3_PodSpec(in.Spec, &out.Spec, c); err != nil {
		return err
	}
	return nil
}

func DeepCopy_v1beta3_Probe(in Probe, out *Probe, c *conversion.Cloner) error {
	if err := DeepCopy_v1beta3_Handler(in.Handler, &out.Handler, c); err != nil {
		return err
	}
	out.InitialDelaySeconds = in.InitialDelaySeconds
	out.TimeoutSeconds = in.TimeoutSeconds
	return nil
}

func DeepCopy_v1beta3_RBDVolumeSource(in RBDVolumeSource, out *RBDVolumeSource, c *conversion.Cloner) error {
	if in.CephMonitors != nil {
		in, out := in.CephMonitors, &out.CephMonitors
		*out = make([]string, len(in))
		copy(*out, in)
	} else {
		out.CephMonitors = nil
	}
	out.RBDImage = in.RBDImage
	out.FSType = in.FSType
	out.RBDPool = in.RBDPool
	out.RadosUser = in.RadosUser
	out.Keyring = in.Keyring
	if in.SecretRef != nil {
		in, out := in.SecretRef, &out.SecretRef
		*out = new(LocalObjectReference)
		if err := DeepCopy_v1beta3_LocalObjectReference(*in, *out, c); err != nil {
			return err
		}
	} else {
		out.SecretRef = nil
	}
	out.ReadOnly = in.ReadOnly
	return nil
}

func DeepCopy_v1beta3_RangeAllocation(in RangeAllocation, out *RangeAllocation, c *conversion.Cloner) error {
	if err := unversioned.DeepCopy_unversioned_TypeMeta(in.TypeMeta, &out.TypeMeta, c); err != nil {
		return err
	}
	if err := DeepCopy_v1beta3_ObjectMeta(in.ObjectMeta, &out.ObjectMeta, c); err != nil {
		return err
	}
	out.Range = in.Range
	if in.Data != nil {
		in, out := in.Data, &out.Data
		*out = make([]byte, len(in))
		copy(*out, in)
	} else {
		out.Data = nil
	}
	return nil
}

func DeepCopy_v1beta3_ReplicationController(in ReplicationController, out *ReplicationController, c *conversion.Cloner) error {
	if err := unversioned.DeepCopy_unversioned_TypeMeta(in.TypeMeta, &out.TypeMeta, c); err != nil {
		return err
	}
	if err := DeepCopy_v1beta3_ObjectMeta(in.ObjectMeta, &out.ObjectMeta, c); err != nil {
		return err
	}
	if err := DeepCopy_v1beta3_ReplicationControllerSpec(in.Spec, &out.Spec, c); err != nil {
		return err
	}
	if err := DeepCopy_v1beta3_ReplicationControllerStatus(in.Status, &out.Status, c); err != nil {
		return err
	}
	return nil
}

func DeepCopy_v1beta3_ReplicationControllerList(in ReplicationControllerList, out *ReplicationControllerList, c *conversion.Cloner) error {
	if err := unversioned.DeepCopy_unversioned_TypeMeta(in.TypeMeta, &out.TypeMeta, c); err != nil {
		return err
	}
	if err := DeepCopy_v1beta3_ListMeta(in.ListMeta, &out.ListMeta, c); err != nil {
		return err
	}
	if in.Items != nil {
		in, out := in.Items, &out.Items
		*out = make([]ReplicationController, len(in))
		for i := range in {
			if err := DeepCopy_v1beta3_ReplicationController(in[i], &(*out)[i], c); err != nil {
				return err
			}
		}
	} else {
		out.Items = nil
	}
	return nil
}

func DeepCopy_v1beta3_ReplicationControllerSpec(in ReplicationControllerSpec, out *ReplicationControllerSpec, c *conversion.Cloner) error {
	if in.Replicas != nil {
		in, out := in.Replicas, &out.Replicas
		*out = new(int)
		**out = *in
	} else {
		out.Replicas = nil
	}
	if in.Selector != nil {
		in, out := in.Selector, &out.Selector
		*out = make(map[string]string)
		for key, val := range in {
			(*out)[key] = val
		}
	} else {
		out.Selector = nil
	}
	if in.Template != nil {
		in, out := in.Template, &out.Template
		*out = new(PodTemplateSpec)
		if err := DeepCopy_v1beta3_PodTemplateSpec(*in, *out, c); err != nil {
			return err
		}
	} else {
		out.Template = nil
	}
	return nil
}

func DeepCopy_v1beta3_ReplicationControllerStatus(in ReplicationControllerStatus, out *ReplicationControllerStatus, c *conversion.Cloner) error {
	out.Replicas = in.Replicas
	out.ObservedGeneration = in.ObservedGeneration
	return nil
}

func DeepCopy_v1beta3_ResourceQuota(in ResourceQuota, out *ResourceQuota, c *conversion.Cloner) error {
	if err := unversioned.DeepCopy_unversioned_TypeMeta(in.TypeMeta, &out.TypeMeta, c); err != nil {
		return err
	}
	if err := DeepCopy_v1beta3_ObjectMeta(in.ObjectMeta, &out.ObjectMeta, c); err != nil {
		return err
	}
	if err := DeepCopy_v1beta3_ResourceQuotaSpec(in.Spec, &out.Spec, c); err != nil {
		return err
	}
	if err := DeepCopy_v1beta3_ResourceQuotaStatus(in.Status, &out.Status, c); err != nil {
		return err
	}
	return nil
}

func DeepCopy_v1beta3_ResourceQuotaList(in ResourceQuotaList, out *ResourceQuotaList, c *conversion.Cloner) error {
	if err := unversioned.DeepCopy_unversioned_TypeMeta(in.TypeMeta, &out.TypeMeta, c); err != nil {
		return err
	}
	if err := DeepCopy_v1beta3_ListMeta(in.ListMeta, &out.ListMeta, c); err != nil {
		return err
	}
	if in.Items != nil {
		in, out := in.Items, &out.Items
		*out = make([]ResourceQuota, len(in))
		for i := range in {
			if err := DeepCopy_v1beta3_ResourceQuota(in[i], &(*out)[i], c); err != nil {
				return err
			}
		}
	} else {
		out.Items = nil
	}
	return nil
}

func DeepCopy_v1beta3_ResourceQuotaSpec(in ResourceQuotaSpec, out *ResourceQuotaSpec, c *conversion.Cloner) error {
	if in.Hard != nil {
		in, out := in.Hard, &out.Hard
		*out = make(ResourceList)
		for key, val := range in {
			newVal := new(resource.Quantity)
			if err := resource.DeepCopy_resource_Quantity(val, newVal, c); err != nil {
				return err
			}
			(*out)[key] = *newVal
		}
	} else {
		out.Hard = nil
	}
	return nil
}

func DeepCopy_v1beta3_ResourceQuotaStatus(in ResourceQuotaStatus, out *ResourceQuotaStatus, c *conversion.Cloner) error {
	if in.Hard != nil {
		in, out := in.Hard, &out.Hard
		*out = make(ResourceList)
		for key, val := range in {
			newVal := new(resource.Quantity)
			if err := resource.DeepCopy_resource_Quantity(val, newVal, c); err != nil {
				return err
			}
			(*out)[key] = *newVal
		}
	} else {
		out.Hard = nil
	}
	if in.Used != nil {
		in, out := in.Used, &out.Used
		*out = make(ResourceList)
		for key, val := range in {
			newVal := new(resource.Quantity)
			if err := resource.DeepCopy_resource_Quantity(val, newVal, c); err != nil {
				return err
			}
			(*out)[key] = *newVal
		}
	} else {
		out.Used = nil
	}
	return nil
}

func DeepCopy_v1beta3_ResourceRequirements(in ResourceRequirements, out *ResourceRequirements, c *conversion.Cloner) error {
	if in.Limits != nil {
		in, out := in.Limits, &out.Limits
		*out = make(ResourceList)
		for key, val := range in {
			newVal := new(resource.Quantity)
			if err := resource.DeepCopy_resource_Quantity(val, newVal, c); err != nil {
				return err
			}
			(*out)[key] = *newVal
		}
	} else {
		out.Limits = nil
	}
	if in.Requests != nil {
		in, out := in.Requests, &out.Requests
		*out = make(ResourceList)
		for key, val := range in {
			newVal := new(resource.Quantity)
			if err := resource.DeepCopy_resource_Quantity(val, newVal, c); err != nil {
				return err
			}
			(*out)[key] = *newVal
		}
	} else {
		out.Requests = nil
	}
	return nil
}

func DeepCopy_v1beta3_RunAsUserStrategyOptions(in RunAsUserStrategyOptions, out *RunAsUserStrategyOptions, c *conversion.Cloner) error {
	out.Type = in.Type
	if in.UID != nil {
		in, out := in.UID, &out.UID
		*out = new(int64)
		**out = *in
	} else {
		out.UID = nil
	}
	if in.UIDRangeMin != nil {
		in, out := in.UIDRangeMin, &out.UIDRangeMin
		*out = new(int64)
		**out = *in
	} else {
		out.UIDRangeMin = nil
	}
	if in.UIDRangeMax != nil {
		in, out := in.UIDRangeMax, &out.UIDRangeMax
		*out = new(int64)
		**out = *in
	} else {
		out.UIDRangeMax = nil
	}
	return nil
}

func DeepCopy_v1beta3_SELinuxContextStrategyOptions(in SELinuxContextStrategyOptions, out *SELinuxContextStrategyOptions, c *conversion.Cloner) error {
	out.Type = in.Type
	if in.SELinuxOptions != nil {
		in, out := in.SELinuxOptions, &out.SELinuxOptions
		*out = new(SELinuxOptions)
		if err := DeepCopy_v1beta3_SELinuxOptions(*in, *out, c); err != nil {
			return err
		}
	} else {
		out.SELinuxOptions = nil
	}
	return nil
}

func DeepCopy_v1beta3_SELinuxOptions(in SELinuxOptions, out *SELinuxOptions, c *conversion.Cloner) error {
	out.User = in.User
	out.Role = in.Role
	out.Type = in.Type
	out.Level = in.Level
	return nil
}

func DeepCopy_v1beta3_Secret(in Secret, out *Secret, c *conversion.Cloner) error {
	if err := unversioned.DeepCopy_unversioned_TypeMeta(in.TypeMeta, &out.TypeMeta, c); err != nil {
		return err
	}
	if err := DeepCopy_v1beta3_ObjectMeta(in.ObjectMeta, &out.ObjectMeta, c); err != nil {
		return err
	}
	if in.Data != nil {
		in, out := in.Data, &out.Data
		*out = make(map[string][]byte)
		for key, val := range in {
			if newVal, err := c.DeepCopy(val); err != nil {
				return err
			} else {
				(*out)[key] = newVal.([]byte)
			}
		}
	} else {
		out.Data = nil
	}
	out.Type = in.Type
	return nil
}

func DeepCopy_v1beta3_SecretList(in SecretList, out *SecretList, c *conversion.Cloner) error {
	if err := unversioned.DeepCopy_unversioned_TypeMeta(in.TypeMeta, &out.TypeMeta, c); err != nil {
		return err
	}
	if err := DeepCopy_v1beta3_ListMeta(in.ListMeta, &out.ListMeta, c); err != nil {
		return err
	}
	if in.Items != nil {
		in, out := in.Items, &out.Items
		*out = make([]Secret, len(in))
		for i := range in {
			if err := DeepCopy_v1beta3_Secret(in[i], &(*out)[i], c); err != nil {
				return err
			}
		}
	} else {
		out.Items = nil
	}
	return nil
}

func DeepCopy_v1beta3_SecretVolumeSource(in SecretVolumeSource, out *SecretVolumeSource, c *conversion.Cloner) error {
	out.SecretName = in.SecretName
	return nil
}

func DeepCopy_v1beta3_SecurityContext(in SecurityContext, out *SecurityContext, c *conversion.Cloner) error {
	if in.Capabilities != nil {
		in, out := in.Capabilities, &out.Capabilities
		*out = new(Capabilities)
		if err := DeepCopy_v1beta3_Capabilities(*in, *out, c); err != nil {
			return err
		}
	} else {
		out.Capabilities = nil
	}
	if in.Privileged != nil {
		in, out := in.Privileged, &out.Privileged
		*out = new(bool)
		**out = *in
	} else {
		out.Privileged = nil
	}
	if in.SELinuxOptions != nil {
		in, out := in.SELinuxOptions, &out.SELinuxOptions
		*out = new(SELinuxOptions)
		if err := DeepCopy_v1beta3_SELinuxOptions(*in, *out, c); err != nil {
			return err
		}
	} else {
		out.SELinuxOptions = nil
	}
	if in.RunAsUser != nil {
		in, out := in.RunAsUser, &out.RunAsUser
		*out = new(int64)
		**out = *in
	} else {
		out.RunAsUser = nil
	}
	if in.RunAsNonRoot != nil {
		in, out := in.RunAsNonRoot, &out.RunAsNonRoot
		*out = new(bool)
		**out = *in
	} else {
		out.RunAsNonRoot = nil
	}
	return nil
}

func DeepCopy_v1beta3_SecurityContextConstraints(in SecurityContextConstraints, out *SecurityContextConstraints, c *conversion.Cloner) error {
	if err := unversioned.DeepCopy_unversioned_TypeMeta(in.TypeMeta, &out.TypeMeta, c); err != nil {
		return err
	}
	if err := DeepCopy_v1beta3_ObjectMeta(in.ObjectMeta, &out.ObjectMeta, c); err != nil {
		return err
	}
	if in.Priority != nil {
		in, out := in.Priority, &out.Priority
		*out = new(int)
		**out = *in
	} else {
		out.Priority = nil
	}
	out.AllowPrivilegedContainer = in.AllowPrivilegedContainer
	if in.DefaultAddCapabilities != nil {
		in, out := in.DefaultAddCapabilities, &out.DefaultAddCapabilities
		*out = make([]Capability, len(in))
		for i := range in {
			(*out)[i] = in[i]
		}
	} else {
		out.DefaultAddCapabilities = nil
	}
	if in.RequiredDropCapabilities != nil {
		in, out := in.RequiredDropCapabilities, &out.RequiredDropCapabilities
		*out = make([]Capability, len(in))
		for i := range in {
			(*out)[i] = in[i]
		}
	} else {
		out.RequiredDropCapabilities = nil
	}
	if in.AllowedCapabilities != nil {
		in, out := in.AllowedCapabilities, &out.AllowedCapabilities
		*out = make([]Capability, len(in))
		for i := range in {
			(*out)[i] = in[i]
		}
	} else {
		out.AllowedCapabilities = nil
	}
	out.AllowHostDirVolumePlugin = in.AllowHostDirVolumePlugin
	out.AllowHostNetwork = in.AllowHostNetwork
	out.AllowHostPorts = in.AllowHostPorts
	out.AllowHostPID = in.AllowHostPID
	out.AllowHostIPC = in.AllowHostIPC
	if err := DeepCopy_v1beta3_SELinuxContextStrategyOptions(in.SELinuxContext, &out.SELinuxContext, c); err != nil {
		return err
	}
	if err := DeepCopy_v1beta3_RunAsUserStrategyOptions(in.RunAsUser, &out.RunAsUser, c); err != nil {
		return err
	}
	if err := DeepCopy_v1beta3_SupplementalGroupsStrategyOptions(in.SupplementalGroups, &out.SupplementalGroups, c); err != nil {
		return err
	}
	if err := DeepCopy_v1beta3_FSGroupStrategyOptions(in.FSGroup, &out.FSGroup, c); err != nil {
		return err
	}
	out.ReadOnlyRootFilesystem = in.ReadOnlyRootFilesystem
	if in.Users != nil {
		in, out := in.Users, &out.Users
		*out = make([]string, len(in))
		copy(*out, in)
	} else {
		out.Users = nil
	}
	if in.Groups != nil {
		in, out := in.Groups, &out.Groups
		*out = make([]string, len(in))
		copy(*out, in)
	} else {
		out.Groups = nil
	}
	return nil
}

func DeepCopy_v1beta3_SecurityContextConstraintsList(in SecurityContextConstraintsList, out *SecurityContextConstraintsList, c *conversion.Cloner) error {
	if err := unversioned.DeepCopy_unversioned_TypeMeta(in.TypeMeta, &out.TypeMeta, c); err != nil {
		return err
	}
	if err := DeepCopy_v1beta3_ListMeta(in.ListMeta, &out.ListMeta, c); err != nil {
		return err
	}
	if in.Items != nil {
		in, out := in.Items, &out.Items
		*out = make([]SecurityContextConstraints, len(in))
		for i := range in {
			if err := DeepCopy_v1beta3_SecurityContextConstraints(in[i], &(*out)[i], c); err != nil {
				return err
			}
		}
	} else {
		out.Items = nil
	}
	return nil
}

func DeepCopy_v1beta3_SerializedReference(in SerializedReference, out *SerializedReference, c *conversion.Cloner) error {
	if err := unversioned.DeepCopy_unversioned_TypeMeta(in.TypeMeta, &out.TypeMeta, c); err != nil {
		return err
	}
	if err := DeepCopy_v1beta3_ObjectReference(in.Reference, &out.Reference, c); err != nil {
		return err
	}
	return nil
}

func DeepCopy_v1beta3_Service(in Service, out *Service, c *conversion.Cloner) error {
	if err := unversioned.DeepCopy_unversioned_TypeMeta(in.TypeMeta, &out.TypeMeta, c); err != nil {
		return err
	}
	if err := DeepCopy_v1beta3_ObjectMeta(in.ObjectMeta, &out.ObjectMeta, c); err != nil {
		return err
	}
	if err := DeepCopy_v1beta3_ServiceSpec(in.Spec, &out.Spec, c); err != nil {
		return err
	}
	if err := DeepCopy_v1beta3_ServiceStatus(in.Status, &out.Status, c); err != nil {
		return err
	}
	return nil
}

func DeepCopy_v1beta3_ServiceAccount(in ServiceAccount, out *ServiceAccount, c *conversion.Cloner) error {
	if err := unversioned.DeepCopy_unversioned_TypeMeta(in.TypeMeta, &out.TypeMeta, c); err != nil {
		return err
	}
	if err := DeepCopy_v1beta3_ObjectMeta(in.ObjectMeta, &out.ObjectMeta, c); err != nil {
		return err
	}
	if in.Secrets != nil {
		in, out := in.Secrets, &out.Secrets
		*out = make([]ObjectReference, len(in))
		for i := range in {
			if err := DeepCopy_v1beta3_ObjectReference(in[i], &(*out)[i], c); err != nil {
				return err
			}
		}
	} else {
		out.Secrets = nil
	}
	if in.ImagePullSecrets != nil {
		in, out := in.ImagePullSecrets, &out.ImagePullSecrets
		*out = make([]LocalObjectReference, len(in))
		for i := range in {
			if err := DeepCopy_v1beta3_LocalObjectReference(in[i], &(*out)[i], c); err != nil {
				return err
			}
		}
	} else {
		out.ImagePullSecrets = nil
	}
	return nil
}

func DeepCopy_v1beta3_ServiceAccountList(in ServiceAccountList, out *ServiceAccountList, c *conversion.Cloner) error {
	if err := unversioned.DeepCopy_unversioned_TypeMeta(in.TypeMeta, &out.TypeMeta, c); err != nil {
		return err
	}
	if err := DeepCopy_v1beta3_ListMeta(in.ListMeta, &out.ListMeta, c); err != nil {
		return err
	}
	if in.Items != nil {
		in, out := in.Items, &out.Items
		*out = make([]ServiceAccount, len(in))
		for i := range in {
			if err := DeepCopy_v1beta3_ServiceAccount(in[i], &(*out)[i], c); err != nil {
				return err
			}
		}
	} else {
		out.Items = nil
	}
	return nil
}

func DeepCopy_v1beta3_ServiceList(in ServiceList, out *ServiceList, c *conversion.Cloner) error {
	if err := unversioned.DeepCopy_unversioned_TypeMeta(in.TypeMeta, &out.TypeMeta, c); err != nil {
		return err
	}
	if err := DeepCopy_v1beta3_ListMeta(in.ListMeta, &out.ListMeta, c); err != nil {
		return err
	}
	if in.Items != nil {
		in, out := in.Items, &out.Items
		*out = make([]Service, len(in))
		for i := range in {
			if err := DeepCopy_v1beta3_Service(in[i], &(*out)[i], c); err != nil {
				return err
			}
		}
	} else {
		out.Items = nil
	}
	return nil
}

func DeepCopy_v1beta3_ServicePort(in ServicePort, out *ServicePort, c *conversion.Cloner) error {
	out.Name = in.Name
	out.Protocol = in.Protocol
	out.Port = in.Port
	if err := intstr.DeepCopy_intstr_IntOrString(in.TargetPort, &out.TargetPort, c); err != nil {
		return err
	}
	out.NodePort = in.NodePort
	return nil
}

func DeepCopy_v1beta3_ServiceSpec(in ServiceSpec, out *ServiceSpec, c *conversion.Cloner) error {
	if in.Ports != nil {
		in, out := in.Ports, &out.Ports
		*out = make([]ServicePort, len(in))
		for i := range in {
			if err := DeepCopy_v1beta3_ServicePort(in[i], &(*out)[i], c); err != nil {
				return err
			}
		}
	} else {
		out.Ports = nil
	}
	if in.Selector != nil {
		in, out := in.Selector, &out.Selector
		*out = make(map[string]string)
		for key, val := range in {
			(*out)[key] = val
		}
	} else {
		out.Selector = nil
	}
	out.PortalIP = in.PortalIP
	out.CreateExternalLoadBalancer = in.CreateExternalLoadBalancer
	out.Type = in.Type
	if in.PublicIPs != nil {
		in, out := in.PublicIPs, &out.PublicIPs
		*out = make([]string, len(in))
		copy(*out, in)
	} else {
		out.PublicIPs = nil
	}
	out.SessionAffinity = in.SessionAffinity
	out.LoadBalancerIP = in.LoadBalancerIP
	return nil
}

func DeepCopy_v1beta3_ServiceStatus(in ServiceStatus, out *ServiceStatus, c *conversion.Cloner) error {
	if err := DeepCopy_v1beta3_LoadBalancerStatus(in.LoadBalancer, &out.LoadBalancer, c); err != nil {
		return err
	}
	return nil
}

func DeepCopy_v1beta3_SupplementalGroupsStrategyOptions(in SupplementalGroupsStrategyOptions, out *SupplementalGroupsStrategyOptions, c *conversion.Cloner) error {
	out.Type = in.Type
	if in.Ranges != nil {
		in, out := in.Ranges, &out.Ranges
		*out = make([]IDRange, len(in))
		for i := range in {
			if err := DeepCopy_v1beta3_IDRange(in[i], &(*out)[i], c); err != nil {
				return err
			}
		}
	} else {
		out.Ranges = nil
	}
	return nil
}

func DeepCopy_v1beta3_TCPSocketAction(in TCPSocketAction, out *TCPSocketAction, c *conversion.Cloner) error {
	if err := intstr.DeepCopy_intstr_IntOrString(in.Port, &out.Port, c); err != nil {
		return err
	}
	return nil
}

func DeepCopy_v1beta3_TypeMeta(in TypeMeta, out *TypeMeta, c *conversion.Cloner) error {
	out.Kind = in.Kind
	out.APIVersion = in.APIVersion
	return nil
}

func DeepCopy_v1beta3_Volume(in Volume, out *Volume, c *conversion.Cloner) error {
	out.Name = in.Name
	if err := DeepCopy_v1beta3_VolumeSource(in.VolumeSource, &out.VolumeSource, c); err != nil {
		return err
	}
	return nil
}

func DeepCopy_v1beta3_VolumeMount(in VolumeMount, out *VolumeMount, c *conversion.Cloner) error {
	out.Name = in.Name
	out.ReadOnly = in.ReadOnly
	out.MountPath = in.MountPath
	return nil
}

func DeepCopy_v1beta3_VolumeSource(in VolumeSource, out *VolumeSource, c *conversion.Cloner) error {
	if in.HostPath != nil {
		in, out := in.HostPath, &out.HostPath
		*out = new(HostPathVolumeSource)
		if err := DeepCopy_v1beta3_HostPathVolumeSource(*in, *out, c); err != nil {
			return err
		}
	} else {
		out.HostPath = nil
	}
	if in.EmptyDir != nil {
		in, out := in.EmptyDir, &out.EmptyDir
		*out = new(EmptyDirVolumeSource)
		if err := DeepCopy_v1beta3_EmptyDirVolumeSource(*in, *out, c); err != nil {
			return err
		}
	} else {
		out.EmptyDir = nil
	}
	if in.GCEPersistentDisk != nil {
		in, out := in.GCEPersistentDisk, &out.GCEPersistentDisk
		*out = new(GCEPersistentDiskVolumeSource)
		if err := DeepCopy_v1beta3_GCEPersistentDiskVolumeSource(*in, *out, c); err != nil {
			return err
		}
	} else {
		out.GCEPersistentDisk = nil
	}
	if in.AWSElasticBlockStore != nil {
		in, out := in.AWSElasticBlockStore, &out.AWSElasticBlockStore
		*out = new(AWSElasticBlockStoreVolumeSource)
		if err := DeepCopy_v1beta3_AWSElasticBlockStoreVolumeSource(*in, *out, c); err != nil {
			return err
		}
	} else {
		out.AWSElasticBlockStore = nil
	}
	if in.GitRepo != nil {
		in, out := in.GitRepo, &out.GitRepo
		*out = new(GitRepoVolumeSource)
		if err := DeepCopy_v1beta3_GitRepoVolumeSource(*in, *out, c); err != nil {
			return err
		}
	} else {
		out.GitRepo = nil
	}
	if in.Secret != nil {
		in, out := in.Secret, &out.Secret
		*out = new(SecretVolumeSource)
		if err := DeepCopy_v1beta3_SecretVolumeSource(*in, *out, c); err != nil {
			return err
		}
	} else {
		out.Secret = nil
	}
	if in.NFS != nil {
		in, out := in.NFS, &out.NFS
		*out = new(NFSVolumeSource)
		if err := DeepCopy_v1beta3_NFSVolumeSource(*in, *out, c); err != nil {
			return err
		}
	} else {
		out.NFS = nil
	}
	if in.ISCSI != nil {
		in, out := in.ISCSI, &out.ISCSI
		*out = new(ISCSIVolumeSource)
		if err := DeepCopy_v1beta3_ISCSIVolumeSource(*in, *out, c); err != nil {
			return err
		}
	} else {
		out.ISCSI = nil
	}
	if in.Glusterfs != nil {
		in, out := in.Glusterfs, &out.Glusterfs
		*out = new(GlusterfsVolumeSource)
		if err := DeepCopy_v1beta3_GlusterfsVolumeSource(*in, *out, c); err != nil {
			return err
		}
	} else {
		out.Glusterfs = nil
	}
	if in.PersistentVolumeClaim != nil {
		in, out := in.PersistentVolumeClaim, &out.PersistentVolumeClaim
		*out = new(PersistentVolumeClaimVolumeSource)
		if err := DeepCopy_v1beta3_PersistentVolumeClaimVolumeSource(*in, *out, c); err != nil {
			return err
		}
	} else {
		out.PersistentVolumeClaim = nil
	}
	if in.RBD != nil {
		in, out := in.RBD, &out.RBD
		*out = new(RBDVolumeSource)
		if err := DeepCopy_v1beta3_RBDVolumeSource(*in, *out, c); err != nil {
			return err
		}
	} else {
		out.RBD = nil
	}
	if in.Cinder != nil {
		in, out := in.Cinder, &out.Cinder
		*out = new(CinderVolumeSource)
		if err := DeepCopy_v1beta3_CinderVolumeSource(*in, *out, c); err != nil {
			return err
		}
	} else {
		out.Cinder = nil
	}
	if in.CephFS != nil {
		in, out := in.CephFS, &out.CephFS
		*out = new(CephFSVolumeSource)
		if err := DeepCopy_v1beta3_CephFSVolumeSource(*in, *out, c); err != nil {
			return err
		}
	} else {
		out.CephFS = nil
	}
	if in.Flocker != nil {
		in, out := in.Flocker, &out.Flocker
		*out = new(FlockerVolumeSource)
		if err := DeepCopy_v1beta3_FlockerVolumeSource(*in, *out, c); err != nil {
			return err
		}
	} else {
		out.Flocker = nil
	}
	if in.DownwardAPI != nil {
		in, out := in.DownwardAPI, &out.DownwardAPI
		*out = new(DownwardAPIVolumeSource)
		if err := DeepCopy_v1beta3_DownwardAPIVolumeSource(*in, *out, c); err != nil {
			return err
		}
	} else {
		out.DownwardAPI = nil
	}
	if in.FC != nil {
		in, out := in.FC, &out.FC
		*out = new(FCVolumeSource)
		if err := DeepCopy_v1beta3_FCVolumeSource(*in, *out, c); err != nil {
			return err
		}
	} else {
		out.FC = nil
	}
	if in.Metadata != nil {
		in, out := in.Metadata, &out.Metadata
		*out = new(MetadataVolumeSource)
		if err := DeepCopy_v1beta3_MetadataVolumeSource(*in, *out, c); err != nil {
			return err
		}
	} else {
		out.Metadata = nil
	}
	return nil
}
