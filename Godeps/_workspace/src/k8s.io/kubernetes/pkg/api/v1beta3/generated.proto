/*
Copyright 2016 The Kubernetes Authors All rights reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/


// This file was autogenerated by go-to-protobuf. Do not edit it manually!

syntax = 'proto2';

package k8s.io.kubernetes.pkg.api.v1beta3;

import "k8s.io/kubernetes/pkg/api/resource/generated.proto";
import "k8s.io/kubernetes/pkg/api/unversioned/generated.proto";
import "k8s.io/kubernetes/pkg/api/v1/generated.proto";
import "k8s.io/kubernetes/pkg/runtime/generated.proto";
import "k8s.io/kubernetes/pkg/util/intstr/generated.proto";

// Package-wide variables from generator "generated".
option go_package = "v1beta3";

// AWSElasticBlockStoreVolumeSource represents a Persistent Disk resource in AWS.
// 
// An AWS PD must exist and be formatted before mounting to a container.
// The disk must also be in the same AWS zone as the kubelet.
// A AWS PD can only be mounted on a single machine.
message AWSElasticBlockStoreVolumeSource {
  // Unique id of the PD resource. Used to identify the disk in AWS
  optional string volumeID = 1;

  // Required: Filesystem type to mount.
  // Must be a filesystem type supported by the host operating system.
  // Ex. "ext4", "xfs", "ntfs"
  // TODO: how do we prevent errors in the filesystem from compromising the machine
  optional string fsType = 2;

  // Optional: Partition on the disk to mount.
  // If omitted, kubelet will attempt to mount the device name.
  // Ex. For /dev/sda1, this field is "1", for /dev/sda, this field 0 or empty.
  optional int64 partition = 3;

  // Optional: Defaults to false (read/write). ReadOnly here will force
  // the ReadOnly setting in VolumeMounts.
  optional bool readOnly = 4;
}

// Binding ties one object to another - for example, a pod is bound to a node by a scheduler.
message Binding {
  // ObjectMeta describes the object that is being bound.
  optional ObjectMeta metadata = 1;

  // Target is the object to bind to.
  optional ObjectReference target = 2;
}

// Capabilities represent POSIX capabilities that can be added or removed to a running container.
message Capabilities {
  // Added capabilities
  repeated string add = 1;

  // Removed capabilities
  repeated string drop = 2;
}

// CephFSVolumeSource represents a Ceph Filesystem Mount that lasts the lifetime of a pod
message CephFSVolumeSource {
  // Required: Monitors is a collection of Ceph monitors
  repeated string monitors = 1;

  // Optional: User is the rados user name, default is admin
  optional string user = 2;

  // Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret
  optional string secretFile = 3;

  // Optional: SecretRef is reference to the authentication secret for User, default is empty.
  optional LocalObjectReference secretRef = 4;

  // Optional: Defaults to false (read/write). ReadOnly here will force
  // the ReadOnly setting in VolumeMounts.
  optional bool readOnly = 5;
}

// CinderVolumeSource represents a cinder volume resource in Openstack.
// A Cinder volume must exist before mounting to a container.
// The volume must also be in the same region as the kubelet.
message CinderVolumeSource {
  // volume id used to identify the volume in cinder
  // More info: http://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md
  optional string volumeID = 1;

  // Required: Filesystem type to mount.
  // Must be a filesystem type supported by the host operating system.
  // Only ext3 and ext4 are allowed
  // More info: http://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md
  optional string fsType = 2;

  // Optional: Defaults to false (read/write). ReadOnly here will force
  // the ReadOnly setting in VolumeMounts.
  // More info: http://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md
  optional bool readOnly = 3;
}

message ComponentCondition {
  optional string type = 1;

  optional string status = 2;

  optional string message = 3;

  optional string error = 4;
}

// ComponentStatus (and ComponentStatusList) holds the cluster validation info.
message ComponentStatus {
  optional ObjectMeta metadata = 1;

  repeated ComponentCondition conditions = 2;
}

message ComponentStatusList {
  optional ListMeta metadata = 1;

  repeated ComponentStatus items = 2;
}

// Container represents a single container that is expected to be run on the host.
message Container {
  // Required: This must be a DNS_LABEL.  Each container in a pod must
  // have a unique name.
  optional string name = 1;

  // Required.
  optional string image = 2;

  // Optional: The docker image's entrypoint is used if this is not provided; cannot be updated.
  // Variable references $(VAR_NAME) are expanded using the container's environment.  If a variable
  // cannot be resolved, the reference in the input string will be unchanged.  The $(VAR_NAME) syntax
  // can be escaped with a double $$, ie: $$(VAR_NAME).  Escaped references will never be expanded,
  // regardless of whether the variable exists or not.
  repeated string command = 3;

  // Optional: The docker image's cmd is used if this is not provided; cannot be updated.
  // Variable references $(VAR_NAME) are expanded using the container's environment.  If a variable
  // cannot be resolved, the reference in the input string will be unchanged.  The $(VAR_NAME) syntax
  // can be escaped with a double $$, ie: $$(VAR_NAME).  Escaped references will never be expanded,
  // regardless of whether the variable exists or not.
  repeated string args = 4;

  // Optional: Defaults to Docker's default.
  optional string workingDir = 5;

  repeated ContainerPort ports = 6;

  repeated EnvVar env = 7;

  optional ResourceRequirements resources = 8;

  repeated VolumeMount volumeMounts = 9;

  optional Probe livenessProbe = 10;

  optional Probe readinessProbe = 11;

  optional Lifecycle lifecycle = 12;

  // Optional: Defaults to /dev/termination-log
  optional string terminationMessagePath = 13;

  // Deprecated - see SecurityContext.  Optional: Default to false.
  optional bool privileged = 14;

  // Optional: Policy for pulling images for this container
  optional string imagePullPolicy = 15;

  // Deprecated - see SecurityContext.  Optional: Capabilities for container.
  optional Capabilities capabilities = 16;

  // Optional: SecurityContext defines the security options the pod should be run with
  optional SecurityContext securityContext = 17;

  // Variables for interactive containers, these have very specialized use-cases (e.g. debugging)
  // and shouldn't be used for general purpose containers.
  optional bool stdin = 18;

  // Whether the container runtime should close the stdin channel after it has been opened by
  // a single attach. When stdin is true the stdin stream will remain open across multiple attach
  // sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the
  // first client attaches to stdin, and then remains open and accepts data until the client disconnects,
  // at which time stdin is closed and remains closed until the container is restarted. If this
  // flag is false, a container processes that reads from stdin will never receive an EOF.
  // Default is false
  optional bool stdinOnce = 19;

  optional bool tty = 20;
}

// ContainerPort represents a network port in a single container.
message ContainerPort {
  // Optional: If specified, this must be a IANA_SVC_NAME.  Each named port
  // in a pod must have a unique name.
  optional string name = 1;

  // Optional: If specified, this must be a valid port number, 0 < x < 65536.
  // If HostNetwork is specified, this must match ContainerPort.
  optional int64 hostPort = 2;

  // Required: This must be a valid port number, 0 < x < 65536.
  optional int64 containerPort = 3;

  // Optional: Defaults to "TCP".
  optional string protocol = 4;

  // Optional: What host IP to bind the external port to.
  optional string hostIP = 5;
}

// ContainerState holds a possible state of container.
// Only one of its members may be specified.
// If none of them is specified, the default one is ContainerStateWaiting.
message ContainerState {
  optional ContainerStateWaiting waiting = 1;

  optional ContainerStateRunning running = 2;

  optional ContainerStateTerminated termination = 3;
}

message ContainerStateRunning {
  optional k8s.io.kubernetes.pkg.api.unversioned.Time startedAt = 1;
}

message ContainerStateTerminated {
  optional int64 exitCode = 1;

  optional int64 signal = 2;

  optional string reason = 3;

  optional string message = 4;

  optional k8s.io.kubernetes.pkg.api.unversioned.Time startedAt = 5;

  optional k8s.io.kubernetes.pkg.api.unversioned.Time finishedAt = 6;

  optional string containerID = 7;
}

message ContainerStateWaiting {
  // Reason could be pulling image,
  optional string reason = 1;

  // Message regarding why the container is not yet running.
  optional string message = 2;
}

message ContainerStatus {
  // Required: This must be a DNS_LABEL.  Each container in a pod must have a unique name.
  optional string name = 1;

  // TODO(dchen1107): Should we rename PodStatus to a more generic name or have a separate states
  // defined for container?
  optional ContainerState state = 2;

  optional ContainerState lastState = 3;

  optional bool ready = 4;

  // Note that this is calculated from dead containers.  But those containers are subject to
  // garbage collection.  This value will get capped at 5 by GC.
  optional int64 restartCount = 5;

  // TODO(dchen1107): Which image the container is running with?
  // The image the container is running
  optional string image = 6;

  optional string imageID = 7;

  optional string containerID = 8;
}

// DaemonEndpoint contains information about a single Daemon endpoint.
message DaemonEndpoint {
  // Port number of the given endpoint.
  optional int64 port = 1;
}

// DeleteOptions may be provided when deleting an API object
message DeleteOptions {
  // Optional duration in seconds before the object should be deleted. Value must be non-negative integer.
  // The value zero indicates delete immediately. If this value is nil, the default grace period for the
  // specified type will be used.
  optional int64 gracePeriodSeconds = 1;
}

// DownwardAPIVolumeFile represents a single file containing information from the downward API
message DownwardAPIVolumeFile {
  // Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
  optional string path = 1;

  // Required: Selects a field of the pod: only annotations, labels, name and  namespace are supported.
  optional ObjectFieldSelector fieldRef = 2;
}

// DownwardAPIVolumeSource represents a volume containing downward API info
message DownwardAPIVolumeSource {
  // Items is a list of DownwardAPIVolume file
  repeated DownwardAPIVolumeFile items = 1;
}

message EmptyDirVolumeSource {
  // Optional: what type of storage medium should back this directory.
  // The default is "" which means to use the node's default medium.
  optional string medium = 1;
}

// EndpointAddress is a tuple that describes single IP address.
message EndpointAddress {
  // The IP of this endpoint.
  // TODO: This should allow hostname or IP, see #4447.
  optional string IP = 1;

  // Optional: The kubernetes object related to the entry point.
  optional ObjectReference targetRef = 2;
}

// EndpointPort is a tuple that describes a single port.
message EndpointPort {
  // The name of this port (corresponds to ServicePort.Name).  Optional
  // if only one port is defined.  Must be a DNS_LABEL.
  optional string name = 1;

  // The port number.
  optional int64 port = 2;

  // The IP protocol for this port.
  optional string protocol = 3;
}

// EndpointSubset is a group of addresses with a common set of ports.  The
// expanded set of endpoints is the Cartesian product of Addresses x Ports.
// For example, given:
//   {
//     Addresses: [{"ip": "10.10.1.1"}, {"ip": "10.10.2.2"}],
//     Ports:     [{"name": "a", "port": 8675}, {"name": "b", "port": 309}]
//   }
// The resulting set of endpoints can be viewed as:
//     a: [ 10.10.1.1:8675, 10.10.2.2:8675 ],
//     b: [ 10.10.1.1:309, 10.10.2.2:309 ]
message EndpointSubset {
  repeated EndpointAddress addresses = 1;

  repeated EndpointAddress notReadyAddresses = 2;

  repeated EndpointPort ports = 3;
}

// Endpoints is a collection of endpoints that implement the actual service.  Example:
//   Name: "mysvc",
//   Subsets: [
//     {
//       Addresses: [{"ip": "10.10.1.1"}, {"ip": "10.10.2.2"}],
//       Ports: [{"name": "a", "port": 8675}, {"name": "b", "port": 309}]
//     },
//     {
//       Addresses: [{"ip": "10.10.3.3"}],
//       Ports: [{"name": "a", "port": 93}, {"name": "b", "port": 76}]
//     },
//  ]
message Endpoints {
  optional ObjectMeta metadata = 1;

  // The set of all endpoints is the union of all subsets.
  repeated EndpointSubset subsets = 2;
}

// EndpointsList is a list of endpoints.
message EndpointsList {
  optional ListMeta metadata = 1;

  repeated Endpoints items = 2;
}

// EnvVar represents an environment variable present in a Container.
message EnvVar {
  // Required: This must be a C_IDENTIFIER.
  optional string name = 1;

  // Optional: no more than one of the following may be specified.
  // Optional: Defaults to ""; variable references $(VAR_NAME) are expanded
  // using the previous defined environment variables in the container and
  // any service environment variables.  If a variable cannot be resolved,
  // the reference in the input string will be unchanged.  The $(VAR_NAME)
  // syntax can be escaped with a double $$, ie: $$(VAR_NAME).  Escaped
  // references will never be expanded, regardless of whether the variable
  // exists or not.
  optional string value = 2;

  // Optional: Specifies a source the value of this var should come from.
  optional EnvVarSource valueFrom = 3;
}

// EnvVarSource represents a source for the value of an EnvVar.
message EnvVarSource {
  // Required: Selects a field of the pod; only name and namespace are supported.
  optional ObjectFieldSelector fieldRef = 1;
}

// Event is a report of an event somewhere in the cluster.
// TODO: Decide whether to store these separately or with the object they apply to.
message Event {
  optional ObjectMeta metadata = 1;

  // Required. The object that this event is about.
  optional ObjectReference involvedObject = 2;

  // Optional; this should be a short, machine understandable string that gives the reason
  // for this event being generated.
  // TODO: provide exact specification for format.
  optional string reason = 3;

  // Optional. A human-readable description of the status of this operation.
  // TODO: decide on maximum length.
  optional string message = 4;

  // Optional. The component reporting this event. Should be a short machine understandable string.
  optional EventSource source = 5;

  // The time at which the event was first recorded. (Time of server receipt is in unversioned.TypeMeta.)
  optional k8s.io.kubernetes.pkg.api.unversioned.Time firstTimestamp = 6;

  // The time at which the most recent occurance of this event was recorded.
  optional k8s.io.kubernetes.pkg.api.unversioned.Time lastTimestamp = 7;

  // The number of times this event has occurred.
  optional int64 count = 8;
}

// EventList is a list of events.
message EventList {
  optional ListMeta metadata = 1;

  repeated Event items = 2;
}

message EventSource {
  // Component from which the event is generated.
  optional string component = 1;

  // Host name on which the event is generated.
  optional string host = 2;
}

// ExecAction describes a "run in container" action.
message ExecAction {
  // Command is the command line to execute inside the container, the working directory for the
  // command  is root ('/') in the container's filesystem.  The command is simply exec'd, it is
  // not run inside a shell, so traditional shell instructions ('|', etc) won't work.  To use
  // a shell, you need to explicitly call out to that shell.
  repeated string command = 1;
}

// A Fibre Channel Disk can only be mounted as read/write once.
message FCVolumeSource {
  // Required: FC target world wide names (WWNs)
  repeated string targetWWNs = 1;

  // Required: FC target lun number
  optional int64 lun = 2;

  // Required: Filesystem type to mount.
  // Must be a filesystem type supported by the host operating system.
  // Ex. "ext4", "xfs", "ntfs"
  // TODO: how do we prevent errors in the filesystem from compromising the machine
  optional string fsType = 3;

  // Optional: Defaults to false (read/write). ReadOnly here will force
  // the ReadOnly setting in VolumeMounts.
  optional bool readOnly = 4;
}

// FSGroupStrategyOptions defines the strategy type and options used to create the strategy.
message FSGroupStrategyOptions {
  // Type is the strategy that will dictate what FSGroup is used in the SecurityContext.
  optional string type = 1;

  // Ranges are the allowed ranges of fs groups.  If you would like to force a single
  // fs group then supply a single range with the same start and end.
  repeated IDRange ranges = 2;
}

// FlockerVolumeSource represents a Flocker volume mounted by the Flocker agent.
message FlockerVolumeSource {
  // Required: the volume name. This is going to be store on metadata -> name on the payload for Flocker
  optional string datasetName = 1;
}

// GCEPersistentDiskVolumeSource represents a Persistent Disk resource in Google Compute Engine.
// 
// A GCE PD must exist and be formatted before mounting to a container.
// The disk must also be in the same GCE project and zone as the kubelet.
// A GCE PD can only be mounted as read/write once.
message GCEPersistentDiskVolumeSource {
  // Unique name of the PD resource. Used to identify the disk in GCE
  optional string pdName = 1;

  // Required: Filesystem type to mount.
  // Must be a filesystem type supported by the host operating system.
  // Ex. "ext4", "xfs", "ntfs"
  // TODO: how do we prevent errors in the filesystem from compromising the machine
  optional string fsType = 2;

  // Optional: Partition on the disk to mount.
  // If omitted, kubelet will attempt to mount the device name.
  // Ex. For /dev/sda1, this field is "1", for /dev/sda, this field is 0 or empty.
  optional int64 partition = 3;

  // Optional: Defaults to false (read/write). ReadOnly here will force
  // the ReadOnly setting in VolumeMounts.
  optional bool readOnly = 4;
}

// GitRepoVolumeSource represents a volume that is pulled from git when the pod is created.
message GitRepoVolumeSource {
  // Repository URL
  optional string repository = 1;

  // Commit hash, this is optional
  optional string revision = 2;
}

// GlusterfsVolumeSource represents a Glusterfs Mount that lasts the lifetime of a pod
message GlusterfsVolumeSource {
  // Required: EndpointsName is the endpoint name that details Glusterfs topology
  optional string endpoints = 1;

  // Required: Path is the Glusterfs volume path
  optional string path = 2;

  // Optional: Defaults to false (read/write). ReadOnly here will force
  // the Glusterfs volume to be mounted with read-only permissions
  optional bool readOnly = 3;
}

// HTTPGetAction describes an action based on HTTP Get requests.
message HTTPGetAction {
  // Optional: Path to access on the HTTP server.
  optional string path = 1;

  // Required: Name or number of the port to access on the container.
  optional k8s.io.kubernetes.pkg.util.intstr.IntOrString port = 2;

  // Optional: Host name to connect to, defaults to the pod IP.
  optional string host = 3;

  // Optional: Scheme to use for connecting to the host, defaults to HTTP.
  optional string scheme = 4;
}

// Handler defines a specific action that should be taken
// TODO: pass structured data to these actions, and document that data here.
message Handler {
  // One and only one of the following should be specified.
  // Exec specifies the action to take.
  optional ExecAction exec = 1;

  // HTTPGet specifies the http request to perform.
  optional HTTPGetAction httpGet = 2;

  // TCPSocket specifies an action involving a TCP port.
  // TODO: implement a realistic TCP lifecycle hook
  optional TCPSocketAction tcpSocket = 3;
}

// HostPathVolumeSource represents bare host directory volume.
message HostPathVolumeSource {
  optional string path = 1;
}

// IDRange provides a min/max of an allowed range of IDs.
// TODO: this could be reused for UIDs.
message IDRange {
  // Min is the start of the range, inclusive.
  optional int64 min = 1;

  // Max is the end of the range, inclusive.
  optional int64 max = 2;
}

// A ISCSI Disk can only be mounted as read/write once.
message ISCSIVolumeSource {
  // Required: iSCSI target portal
  // the portal is either an IP or ip_addr:port if port is other than default (typically TCP ports 860 and 3260)
  optional string targetPortal = 1;

  // Required:  target iSCSI Qualified Name
  optional string iqn = 2;

  // Required: iSCSI target lun number
  optional int64 lun = 3;

  // Required: Filesystem type to mount.
  // Must be a filesystem type supported by the host operating system.
  // Ex. "ext4", "xfs", "ntfs"
  // TODO: how do we prevent errors in the filesystem from compromising the machine
  optional string fsType = 4;

  // Optional: Defaults to false (read/write). ReadOnly here will force
  // the ReadOnly setting in VolumeMounts.
  optional bool readOnly = 5;
}

// Lifecycle describes actions that the management system should take in response to container lifecycle
// events.  For the PostStart and PreStop lifecycle handlers, management of the container blocks
// until the action is complete, unless the container process fails, in which case the handler is aborted.
message Lifecycle {
  // PostStart is called immediately after a container is created.  If the handler fails, the container
  // is terminated and restarted.
  optional Handler postStart = 1;

  // PreStop is called immediately before a container is terminated.  The reason for termination is
  // passed to the handler.  Regardless of the outcome of the handler, the container is eventually terminated.
  optional Handler preStop = 2;
}

// LimitRange sets resource usage limits for each kind of resource in a Namespace
message LimitRange {
  optional ObjectMeta metadata = 1;

  // Spec defines the limits enforced
  optional LimitRangeSpec spec = 2;
}

// LimitRangeItem defines a min/max usage limit for any resource that matches on kind
message LimitRangeItem {
  // Type of resource that this limit applies to
  optional string type = 1;

  // Max usage constraints on this kind by resource name
  map<string, k8s.io.kubernetes.pkg.api.resource.Quantity> max = 2;

  // Min usage constraints on this kind by resource name
  map<string, k8s.io.kubernetes.pkg.api.resource.Quantity> min = 3;

  // Default usage constraints on this kind by resource name
  map<string, k8s.io.kubernetes.pkg.api.resource.Quantity> default = 4;

  // DefaultRequest is the default resource requirement request value by resource name if resource request is omitted.
  map<string, k8s.io.kubernetes.pkg.api.resource.Quantity> defaultRequest = 5;

  // MaxLimitRequestRatio if specified, the named resource must have a request and limit that are both non-zero where limit divided by request is less than or equal to the enumerated value; this represents the max burst for the named resource.
  map<string, k8s.io.kubernetes.pkg.api.resource.Quantity> maxLimitRequestRatio = 6;
}

// LimitRangeList is a list of LimitRange items.
message LimitRangeList {
  optional ListMeta metadata = 1;

  // Items is a list of LimitRange objects
  repeated LimitRange items = 2;
}

// LimitRangeSpec defines a min/max usage limit for resources that match on kind
message LimitRangeSpec {
  // Limits is the list of LimitRangeItem objects that are enforced
  repeated LimitRangeItem limits = 1;
}

// List holds a list of objects, which may not be known by the server.
message List {
  optional ListMeta metadata = 1;

  repeated k8s.io.kubernetes.pkg.runtime.RawExtension items = 2;
}

// ListMeta describes metadata that synthetic resources must have, including lists and
// various status objects.
message ListMeta {
  // SelfLink is a URL representing this object.
  optional string selfLink = 1;

  // An opaque value that represents the version of this response for use with optimistic
  // concurrency and change monitoring endpoints.  Clients must treat these values as opaque
  // and values may only be valid for a particular resource or set of resources. Only servers
  // will generate resource versions.
  optional string resourceVersion = 2;
}

// ListOptions is the query options to a standard REST list call
message ListOptions {
  // A selector based on labels
  optional string labelSelector = 1;

  // A selector based on fields
  optional string fieldSelector = 2;

  // If true, watch for changes to the selected resources
  optional bool watch = 3;

  // The desired resource version to watch
  optional string resourceVersion = 4;
}

// LoadBalancerIngress represents the status of a load-balancer ingress point:
// traffic intended for the service should be sent to an ingress point.
message LoadBalancerIngress {
  // IP is set for load-balancer ingress points that are IP based
  // (typically GCE or OpenStack load-balancers)
  optional string ip = 1;

  // Hostname is set for load-balancer ingress points that are DNS based
  // (typically AWS load-balancers)
  optional string hostname = 2;
}

// LoadBalancerStatus represents the status of a load-balancer
message LoadBalancerStatus {
  // Ingress is a list containing ingress points for the load-balancer;
  // traffic intended for the service should be sent to these ingress points.
  repeated LoadBalancerIngress ingress = 1;
}

// LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
message LocalObjectReference {
  // TODO: Add other useful fields.  apiVersion, kind, uid?
  optional string name = 1;
}

// MetadataFile expresses information about a file holding pod metadata.
// NOTE: Deprecated in favor of DownwardAPIVolumeFile
message MetadataFile {
  // Required: Name is the name of the file
  optional string name = 1;

  // Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
  optional ObjectFieldSelector fieldRef = 2;
}

// MetadataVolumeSource represents a volume containing metadata about a pod.
// NOTE: Deprecated in favor of DownwardAPIVolumeSource
message MetadataVolumeSource {
  // Items is a list of metadata file name
  repeated MetadataFile items = 1;
}

// NFSVolumeSource represents an NFS mount that lasts the lifetime of a pod
message NFSVolumeSource {
  // Server is the hostname or IP address of the NFS server
  optional string server = 1;

  // Path is the exported NFS share
  optional string path = 2;

  // Optional: Defaults to false (read/write). ReadOnly here will force
  // the NFS export to be mounted with read-only permissions
  optional bool readOnly = 3;
}

// A namespace provides a scope for Names.
// Use of multiple namespaces is optional
message Namespace {
  optional ObjectMeta metadata = 1;

  // Spec defines the behavior of the Namespace.
  optional NamespaceSpec spec = 2;

  // Status describes the current status of a Namespace
  optional NamespaceStatus status = 3;
}

// NamespaceList is a list of Namespaces.
message NamespaceList {
  optional ListMeta metadata = 1;

  // Items is the list of Namespace objects in the list
  repeated Namespace items = 2;
}

// NamespaceSpec describes the attributes on a Namespace
message NamespaceSpec {
  // Finalizers is an opaque list of values that must be empty to permanently remove object from storage
  repeated string finalizers = 1;
}

// NamespaceStatus is information about the current status of a Namespace.
message NamespaceStatus {
  // Phase is the current lifecycle phase of the namespace.
  optional string phase = 1;
}

// Node is a worker node in Kubernetes.
// The name of the node according to etcd is in ID.
message Node {
  optional ObjectMeta metadata = 1;

  // Spec defines the behavior of a node.
  optional NodeSpec spec = 2;

  // Status describes the current status of a Node
  optional NodeStatus status = 3;
}

message NodeAddress {
  optional string type = 1;

  optional string address = 2;
}

message NodeCondition {
  optional string type = 1;

  optional string status = 2;

  optional k8s.io.kubernetes.pkg.api.unversioned.Time lastHeartbeatTime = 3;

  optional k8s.io.kubernetes.pkg.api.unversioned.Time lastTransitionTime = 4;

  optional string reason = 5;

  optional string message = 6;
}

// NodeDaemonEndpoints lists ports opened by daemons running on the Node.
message NodeDaemonEndpoints {
  // Endpoint on which Kubelet is listening.
  optional DaemonEndpoint kubeletEndpoint = 1;
}

// NodeList is a list of minions.
message NodeList {
  optional ListMeta metadata = 1;

  repeated Node items = 2;
}

// NodeSpec describes the attributes that a node is created with.
message NodeSpec {
  // PodCIDR represents the pod IP range assigned to the node
  optional string podCIDR = 1;

  // External ID of the node assigned by some machine database (e.g. a cloud provider)
  optional string externalID = 2;

  // ID of the node assigned by the cloud provider
  optional string providerID = 3;

  // Unschedulable controls node schedulability of new pods. By default node is schedulable.
  optional bool unschedulable = 4;
}

// NodeStatus is information about the current status of a node.
message NodeStatus {
  // Capacity represents the available resources of a node.
  // see http://releases.k8s.io/v1.0.0/docs/resources.md for more details.
  map<string, k8s.io.kubernetes.pkg.api.resource.Quantity> capacity = 1;

  // NodePhase is the current lifecycle phase of the node.
  optional string phase = 2;

  // Conditions is an array of current node conditions.
  repeated NodeCondition conditions = 3;

  // Queried from cloud provider, if available.
  repeated NodeAddress addresses = 4;

  // Endpoints of daemons running on the Node.
  optional NodeDaemonEndpoints daemonEndpoints = 5;

  // NodeSystemInfo is a set of ids/uuids to uniquely identify the node
  optional NodeSystemInfo nodeInfo = 6;
}

// NodeSystemInfo is a set of ids/uuids to uniquely identify the node.
message NodeSystemInfo {
  // MachineID is the machine-id reported by the node
  optional string machineID = 1;

  // SystemUUID is the system-uuid reported by the node
  optional string systemUUID = 2;

  // BootID is the boot-id reported by the node
  optional string bootID = 3;

  // Kernel version reported by the node
  optional string kernelVersion = 4;

  // OS image used reported by the node
  optional string osImage = 5;

  // Container runtime version reported by the node
  optional string containerRuntimeVersion = 6;

  // Kubelet version reported by the node
  optional string kubeletVersion = 7;

  // Kube-proxy version reported by the node
  optional string kubeProxyVersion = 8;
}

// ObjectFieldSelector selects an APIVersioned field of an object.
message ObjectFieldSelector {
  // Optional: Version of the schema the FieldPath is written in terms of, defaults to "v1beta3"
  optional string apiVersion = 1;

  // Required: Path of the field to select in the specified API version
  optional string fieldPath = 2;
}

// ObjectMeta is metadata that all persisted resources must have, which includes all objects
// users must create.
message ObjectMeta {
  // Name is unique within a namespace.  Name is required when creating resources, although
  // some resources may allow a client to request the generation of an appropriate name
  // automatically. Name is primarily intended for creation idempotence and configuration
  // definition.
  optional string name = 1;

  // GenerateName indicates that the name should be made unique by the server prior to persisting
  // it. A non-empty value for the field indicates the name will be made unique (and the name
  // returned to the client will be different than the name passed). The value of this field will
  // be combined with a unique suffix on the server if the Name field has not been provided.
  // The provided value must be valid within the rules for Name, and may be truncated by the length
  // of the suffix required to make the value unique on the server.
  // 
  // If this field is specified, and Name is not present, the server will NOT return a 409 if the
  // generated name exists - instead, it will either return 201 Created or 500 with Reason
  // ServerTimeout indicating a unique name could not be found in the time allotted, and the client
  // should retry (optionally after the time indicated in the Retry-After header).
  optional string generateName = 2;

  // Namespace defines the space within which name must be unique. An empty namespace is
  // equivalent to the "default" namespace, but "default" is the canonical representation.
  // Not all objects are required to be scoped to a namespace - the value of this field for
  // those objects will be empty.
  optional string namespace = 3;

  // SelfLink is a URL representing this object.
  optional string selfLink = 4;

  // UID is the unique in time and space value for this object. It is typically generated by
  // the server on successful creation of a resource and is not allowed to change on PUT
  // operations.
  optional string uid = 5;

  // An opaque value that represents the version of this resource. May be used for optimistic
  // concurrency, change detection, and the watch operation on a resource or set of resources.
  // Clients must treat these values as opaque and values may only be valid for a particular
  // resource or set of resources. Only servers will generate resource versions.
  optional string resourceVersion = 6;

  // A sequence number representing a specific generation of the desired state.
  // Currently only implemented by replication controllers.
  optional int64 generation = 7;

  // CreationTimestamp is a timestamp representing the server time when this object was
  // created. It is not guaranteed to be set in happens-before order across separate operations.
  // Clients may not set this value. It is represented in RFC3339 form and is in UTC.
  optional k8s.io.kubernetes.pkg.api.unversioned.Time creationTimestamp = 8;

  // DeletionTimestamp is the time after which this resource will be deleted. This
  // field is set by the server when a graceful deletion is requested by the user, and is not
  // directly settable by a client. The resource will be deleted (no longer visible from
  // resource lists, and not reachable by name) after the time in this field. Once set, this
  // value may not be unset or be set further into the future, although it may be shortened
  // or the resource may be deleted prior to this time. For example, a user may request that
  // a pod is deleted in 30 seconds. The Kubelet will react by sending a graceful termination
  // signal to the containers in the pod. Once the resource is deleted in the API, the Kubelet
  // will send a hard termination signal to the container.
  optional k8s.io.kubernetes.pkg.api.unversioned.Time deletionTimestamp = 9;

  // Number of seconds allowed for this object to gracefully terminate before
  // it will be removed from the system. Only set when deletionTimestamp is also set.
  // May only be shortened.
  // Read-only.
  optional int64 deletionGracePeriodSeconds = 10;

  // Labels are key value pairs that may be used to scope and select individual resources.
  // TODO: replace map[string]string with labels.LabelSet type
  map<string, string> labels = 11;

  // Annotations are unstructured key value data stored with a resource that may be set by
  // external tooling. They are not queryable and should be preserved when modifying
  // objects.
  map<string, string> annotations = 12;
}

// ObjectReference contains enough information to let you inspect or modify the referred object.
message ObjectReference {
  optional string kind = 1;

  optional string namespace = 2;

  optional string name = 3;

  optional string uid = 4;

  optional string apiVersion = 5;

  optional string resourceVersion = 6;

  // Optional. If referring to a piece of an object instead of an entire object, this string
  // should contain information to identify the sub-object. For example, if the object
  // reference is to a container within a pod, this would take on a value like:
  // "spec.containers{name}" (where "name" refers to the name of the container that triggered
  // the event) or if no container name is specified "spec.containers[2]" (container with
  // index 2 in this pod). This syntax is chosen only to have some well-defined way of
  // referencing a part of an object.
  // TODO: this design is not final and this field is subject to change in the future.
  optional string fieldPath = 7;
}

message PersistentVolume {
  optional ObjectMeta metadata = 1;

  // Spec defines a persistent volume owned by the cluster
  optional PersistentVolumeSpec spec = 2;

  // Status represents the current information about persistent volume.
  optional PersistentVolumeStatus status = 3;
}

// PersistentVolumeClaim is a user's request for and claim to a persistent volume
message PersistentVolumeClaim {
  optional ObjectMeta metadata = 1;

  // Spec defines the volume requested by a pod author
  optional PersistentVolumeClaimSpec spec = 2;

  // Status represents the current information about a claim
  optional PersistentVolumeClaimStatus status = 3;
}

message PersistentVolumeClaimList {
  optional ListMeta metadata = 1;

  repeated PersistentVolumeClaim items = 2;
}

// PersistentVolumeClaimSpec describes the common attributes of storage devices
// and allows a Source for provider-specific attributes
message PersistentVolumeClaimSpec {
  // Contains the types of access modes required
  repeated string accessModes = 1;

  // Resources represents the minimum resources required
  optional ResourceRequirements resources = 2;

  // VolumeName is the binding reference to the PersistentVolume backing this claim
  optional string volumeName = 3;
}

message PersistentVolumeClaimStatus {
  // Phase represents the current phase of PersistentVolumeClaim
  optional string phase = 1;

  // AccessModes contains all ways the volume backing the PVC can be mounted
  repeated string accessModes = 2;

  // Represents the actual resources of the underlying volume
  map<string, k8s.io.kubernetes.pkg.api.resource.Quantity> capacity = 3;
}

message PersistentVolumeClaimVolumeSource {
  // ClaimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume
  optional string claimName = 1;

  // Optional: Defaults to false (read/write).  ReadOnly here
  // will force the ReadOnly setting in VolumeMounts
  optional bool readOnly = 2;
}

message PersistentVolumeList {
  optional ListMeta metadata = 1;

  repeated PersistentVolume items = 2;
}

// Similar to VolumeSource but meant for the administrator who creates PVs.
// Exactly one of its members must be set.
message PersistentVolumeSource {
  // GCEPersistentDisk represents a GCE Disk resource that is attached to a
  // kubelet's host machine and then exposed to the pod.
  optional GCEPersistentDiskVolumeSource gcePersistentDisk = 1;

  // AWSElasticBlockStore represents an AWS Disk resource that is attached to a
  // kubelet's host machine and then exposed to the pod.
  optional AWSElasticBlockStoreVolumeSource awsElasticBlockStore = 2;

  // HostPath represents a directory on the host.
  // This is useful for development and testing only.
  // on-host storage is not supported in any way.
  optional HostPathVolumeSource hostPath = 3;

  // Glusterfs represents a Glusterfs volume that is attached to a host and exposed to the pod
  optional GlusterfsVolumeSource glusterfs = 4;

  // NFS represents an NFS mount on the host
  optional NFSVolumeSource nfs = 5;

  // RBD represents a Rados Block Device mount on the host that shares a pod's lifetime
  optional RBDVolumeSource rbd = 6;

  // ISCSI represents an ISCSI Disk resource that is attached to a
  // kubelet's host machine and then exposed to the pod.
  optional ISCSIVolumeSource iscsi = 7;

  // CephFS represents a Ceph FS mount on the host that shares a pod's lifetime
  optional CephFSVolumeSource cephfs = 8;

  // Cinder represents a cinder volume attached and mounted on kubelets host machine
  // More info: http://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md
  optional CinderVolumeSource cinder = 9;

  // FC represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
  optional FCVolumeSource fc = 10;

  // Flocker represents a Flocker volume attached to a kubelet's host machine and exposed to the pod for its usage. This depends on the Flocker control service being running
  optional FlockerVolumeSource flocker = 11;
}

message PersistentVolumeSpec {
  // Resources represents the actual resources of the volume
  map<string, k8s.io.kubernetes.pkg.api.resource.Quantity> capacity = 1;

  // Source represents the location and type of a volume to mount.
  optional PersistentVolumeSource persistentVolumeSource = 2;

  // AccessModes contains all ways the volume can be mounted
  repeated string accessModes = 3;

  // ClaimRef is part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim.
  // ClaimRef is expected to be non-nil when bound.
  // claim.VolumeName is the authoritative bind between PV and PVC.
  optional ObjectReference claimRef = 4;

  // Optional: what happens to a persistent volume when released from its claim.
  optional string persistentVolumeReclaimPolicy = 5;
}

message PersistentVolumeStatus {
  // Phase indicates if a volume is available, bound to a claim, or released by a claim
  optional string phase = 1;

  // A human-readable message indicating details about why the volume is in this state.
  optional string message = 2;

  // Reason is a brief CamelCase string that describes any failure and is meant for machine parsing and tidy display in the CLI
  optional string reason = 3;
}

// Pod is a collection of containers that can run on a host. This resource is created
// by clients and scheduled onto hosts.
message Pod {
  optional ObjectMeta metadata = 1;

  // Spec defines the behavior of a pod.
  optional PodSpec spec = 2;

  // Status represents the current information about a pod. This data may not be up
  // to date.
  optional PodStatus status = 3;
}

// PodAttachOptions is the query options to a Pod's remote attach call.
// ---
// TODO: merge w/ PodExecOptions below for stdin, stdout, etc
// and also when we cut V2, we should export a "StreamOptions" or somesuch that contains Stdin, Stdout, Stder and TTY
message PodAttachOptions {
  // Stdin if true, redirects the standard input stream of the pod for this call.
  // Defaults to false.
  optional bool stdin = 1;

  // Stdout if true indicates that stdout is to be redirected for the attach call.
  // Defaults to true.
  optional bool stdout = 2;

  // Stderr if true indicates that stderr is to be redirected for the attach call.
  // Defaults to true.
  optional bool stderr = 3;

  // TTY if true indicates that a tty will be allocated for the attach call.
  // This is passed through the container runtime so the tty
  // is allocated on the worker node by the container runtime.
  // Defaults to false.
  optional bool tty = 4;

  // The container in which to execute the command.
  // Defaults to only container if there is only one container in the pod.
  optional string container = 5;
}

message PodCondition {
  // Type is the type of the condition
  optional string type = 1;

  // Status is the status of the condition
  optional string status = 2;

  // Last time we probed the condition.
  optional k8s.io.kubernetes.pkg.api.unversioned.Time lastProbeTime = 3;

  // Last time the condition transitioned from one status to another.
  optional k8s.io.kubernetes.pkg.api.unversioned.Time lastTransitionTime = 4;

  // Unique, one-word, CamelCase reason for the condition's last transition.
  optional string reason = 5;

  // Human-readable message indicating details about last transition.
  optional string message = 6;
}

// PodExecOptions is the query options to a Pod's remote exec call
// ---
// TODO: This is largely identical to PodAttachOptions above, make sure they stay in sync and see about merging
// and also when we cut V2, we should export a "StreamOptions" or somesuch that contains Stdin, Stdout, Stder and TTY
message PodExecOptions {
  // Stdin if true indicates that stdin is to be redirected for the exec call
  optional bool stdin = 1;

  // Stdout if true indicates that stdout is to be redirected for the exec call
  optional bool stdout = 2;

  // Stderr if true indicates that stderr is to be redirected for the exec call
  optional bool stderr = 3;

  // TTY if true indicates that a tty will be allocated for the exec call
  optional bool tty = 4;

  // Container in which to execute the command.
  optional string container = 5;

  // Command is the remote command to execute; argv array; not executed within a shell.
  repeated string command = 6;
}

// PodList is a list of Pods.
message PodList {
  optional ListMeta metadata = 1;

  repeated Pod items = 2;
}

// PodLogOptions is the query options for a Pod's logs REST call
message PodLogOptions {
  // Container for which to return logs
  optional string container = 1;

  // If true, follow the logs for the pod
  optional bool follow = 2;

  //  If true, return previous terminated container logs
  optional bool previous = 3;

  // A relative time in seconds before the current time from which to show logs. If this value
  // precedes the time a pod was started, only logs since the pod start will be returned.
  // If this value is in the future, no logs will be returned.
  // Only one of sinceSeconds or sinceTime may be specified.
  optional int64 sinceSeconds = 4;

  // An RFC3339 timestamp from which to show logs. If this value
  // preceeds the time a pod was started, only logs since the pod start will be returned.
  // If this value is in the future, no logs will be returned.
  // Only one of sinceSeconds or sinceTime may be specified.
  optional k8s.io.kubernetes.pkg.api.unversioned.Time sinceTime = 5;

  // If true, add an RFC3339 or RFC3339Nano timestamp at the beginning of every line
  // of log output. Defaults to false.
  optional bool timestamps = 6;

  // If set, the number of lines from the end of the logs to show. If not specified,
  // logs are shown from the creation of the container or sinceSeconds or sinceTime
  optional int64 tailLines = 7;

  // If set, the number of bytes to read from the server before terminating the
  // log output. This may not display a complete final line of logging, and may return
  // slightly more or slightly less than the specified limit.
  optional int64 limitBytes = 8;
}

// PodProxyOptions is the query options to a Pod's proxy call
message PodProxyOptions {
  // Path is the URL path to use for the current proxy request
  optional string path = 1;
}

// PodSecurityContext holds pod-level security attributes and common container settings.
// Some fields are also present in container.securityContext.  Field values of
// container.securityContext take precedence over field values of PodSecurityContext.
message PodSecurityContext {
  // The SELinux context to be applied to all containers.
  // If unspecified, the container runtime will allocate a random SELinux context for each
  // container.  May also be set in SecurityContext.  If set in
  // both SecurityContext and PodSecurityContext, the value specified in SecurityContext
  // takes precedence for that container.
  optional SELinuxOptions seLinuxOptions = 1;

  // The UID to run the entrypoint of the container process.
  // Defaults to user specified in image metadata if unspecified.
  // May also be set in SecurityContext.  If set in both SecurityContext and
  // PodSecurityContext, the value specified in SecurityContext takes precedence
  // for that container.
  optional int64 runAsUser = 2;

  // Indicates that the container must run as a non-root user.
  // If true, the Kubelet will validate the image at runtime to ensure that it
  // does not run as UID 0 (root) and fail to start the container if it does.
  // If unset or false, no such validation will be performed.
  // May also be set in SecurityContext.  If set in both SecurityContext and
  // PodSecurityContext, the value specified in SecurityContext takes precedence.
  optional bool runAsNonRoot = 3;

  // A list of groups applied to the first process run in each container, in addition
  // to the container's primary GID.  If unspecified, no groups will be added to
  // any container.
  repeated int64 supplementalGroups = 4;

  // A special supplemental group that applies to all containers in a pod.
  // Some volume types allow the Kubelet to change the ownership of that volume
  // to be owned by the pod:
  // 
  // 1. The owning GID will be the FSGroup
  // 2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
  // 3. The permission bits are OR'd with rw-rw----
  // 
  // If unset, the Kubelet will not modify the ownership and permissions of any volume.
  optional int64 fsGroup = 5;
}

// PodSpec is a description of a pod
message PodSpec {
  repeated Volume volumes = 1;

  // Required: there must be at least one container in a pod.
  repeated Container containers = 2;

  optional string restartPolicy = 3;

  // Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request.
  // Value must be non-negative integer. The value zero indicates delete immediately.
  // If this value is nil, the default grace period will be used instead.
  // The grace period is the duration in seconds after the processes running in the pod are sent
  // a termination signal and the time when the processes are forcibly halted with a kill signal.
  // Set this value longer than the expected cleanup time for your process.
  optional int64 terminationGracePeriodSeconds = 4;

  optional int64 activeDeadlineSeconds = 5;

  // Optional: Set DNS policy.  Defaults to "ClusterFirst"
  optional string dnsPolicy = 6;

  // NodeSelector is a selector which must be true for the pod to fit on a node
  map<string, string> nodeSelector = 7;

  // ServiceAccount is the name of the ServiceAccount to use to run this pod
  optional string serviceAccount = 8;

  // Host is a request to schedule this pod onto a specific host.  If it is non-empty,
  // the the scheduler simply schedules this pod onto that host, assuming that it fits
  // resource requirements.
  optional string host = 9;

  // Uses the host's network namespace. If this option is set, the ports that will be
  // used must be specified.
  // Optional: Default to false.
  optional bool hostNetwork = 10;

  // Use the host's pid namespace.
  // Optional: Default to false.
  optional bool hostPID = 11;

  // Use the host's ipc namespace.
  // Optional: Default to false.
  optional bool hostIPC = 12;

  // SecurityContext holds pod-level security attributes and common container settings.
  // Optional: Defaults to empty.  See type description for default values of each field.
  optional PodSecurityContext securityContext = 13;

  // ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec.
  // If specified, these secrets will be passed to individual puller implementations for them to use.  For example,
  // in the case of docker, only DockerConfig type secrets are honored.
  repeated LocalObjectReference imagePullSecrets = 14;
}

// PodStatus represents information about the status of a pod. Status may trail the actual
// state of a system.
message PodStatus {
  optional string phase = 1;

  repeated PodCondition Condition = 2;

  // A human readable message indicating details about why the pod is in this state.
  optional string message = 3;

  // A brief CamelCase message indicating details about why the pod is in this state. e.g. 'OutOfDisk'
  optional string reason = 4;

  optional string hostIP = 5;

  optional string podIP = 6;

  optional k8s.io.kubernetes.pkg.api.unversioned.Time startTime = 7;

  // The list has one entry per container in the manifest. Each entry is currently the output
  // of `docker inspect`.
  repeated ContainerStatus containerStatuses = 8;
}

// PodStatusResult is a wrapper for PodStatus returned by kubelet that can be encode/decoded
message PodStatusResult {
  optional ObjectMeta metadata = 1;

  // Status represents the current information about a pod. This data may not be up
  // to date.
  optional PodStatus status = 2;
}

// PodTemplate describes a template for creating copies of a predefined pod.
message PodTemplate {
  optional ObjectMeta metadata = 1;

  // Template defines the pods that will be created from this pod template
  optional PodTemplateSpec template = 2;
}

// PodTemplateList is a list of PodTemplates.
message PodTemplateList {
  optional ListMeta metadata = 1;

  repeated PodTemplate items = 2;
}

// PodTemplateSpec describes the data a pod should have when created from a template
message PodTemplateSpec {
  // Metadata of the pods created from this template.
  optional ObjectMeta metadata = 1;

  // Spec defines the behavior of a pod.
  optional PodSpec spec = 2;
}

// Probe describes a liveness probe to be examined to the container.
message Probe {
  // The action taken to determine the health of a container
  optional Handler handler = 1;

  // Length of time before health checking is activated.  In seconds.
  optional int64 initialDelaySeconds = 2;

  // Length of time before health checking times out.  In seconds.
  optional int64 timeoutSeconds = 3;
}

// RBDVolumeSource represents a Rados Block Device Mount that lasts the lifetime of a pod
message RBDVolumeSource {
  // Required: CephMonitors is a collection of Ceph monitors
  repeated string monitors = 1;

  // Required: RBDImage is the rados image name
  optional string image = 2;

  // Required: Filesystem type to mount.
  // Must be a filesystem type supported by the host operating system.
  // Ex. "ext4", "xfs", "ntfs"
  // TODO: how do we prevent errors in the filesystem from compromising the machine
  optional string fsType = 3;

  // Optional: RadosPool is the rados pool name,default is rbd
  optional string pool = 4;

  // Optional: RBDUser is the rados user name, default is admin
  optional string user = 5;

  // Optional: Keyring is the path to key ring for RBDUser, default is /etc/ceph/keyring
  optional string keyring = 6;

  // Optional: SecretRef is name of the authentication secret for RBDUser, default is empty.
  optional LocalObjectReference secretRef = 7;

  // Optional: Defaults to false (read/write). ReadOnly here will force
  // the ReadOnly setting in VolumeMounts.
  optional bool readOnly = 8;
}

// RangeAllocation is not a public type
message RangeAllocation {
  optional ObjectMeta metadata = 1;

  optional string range = 2;

  optional bytes data = 3;
}

// ReplicationController represents the configuration of a replication controller.
message ReplicationController {
  // If the Labels of a ReplicationController are empty, they are defaulted to be the same as the Pod(s) that the replication controller manages.
  optional ObjectMeta metadata = 1;

  // Spec defines the desired behavior of this replication controller.
  optional ReplicationControllerSpec spec = 2;

  // Status is the current status of this replication controller. This data may be
  // out of date by some window of time.
  optional ReplicationControllerStatus status = 3;
}

// ReplicationControllerList is a collection of replication controllers.
message ReplicationControllerList {
  optional ListMeta metadata = 1;

  repeated ReplicationController items = 2;
}

// ReplicationControllerSpec is the specification of a replication controller.
message ReplicationControllerSpec {
  // Replicas is the number of desired replicas. This is a pointer to distinguish between explicit zero and unspecified.
  optional int64 replicas = 1;

  // Selector is a label query over pods that should match the Replicas count.
  // If Selector is empty, it is defaulted to the labels present on the Pod template.
  map<string, string> selector = 2;

  // Template is the object that describes the pod that will be created if
  // insufficient replicas are detected. This takes precedence over a
  // TemplateRef.
  optional PodTemplateSpec template = 3;
}

// ReplicationControllerStatus represents the current status of a replication
// controller.
message ReplicationControllerStatus {
  // Replicas is the number of actual replicas.
  optional int64 replicas = 1;

  // ObservedGeneration is the most recent generation observed by the controller.
  optional int64 observedGeneration = 2;
}

// ResourceQuota sets aggregate quota restrictions enforced per namespace
message ResourceQuota {
  optional ObjectMeta metadata = 1;

  // Spec defines the desired quota
  optional ResourceQuotaSpec spec = 2;

  // Status defines the actual enforced quota and its current usage
  optional ResourceQuotaStatus status = 3;
}

// ResourceQuotaList is a list of ResourceQuota items
message ResourceQuotaList {
  optional ListMeta metadata = 1;

  // Items is a list of ResourceQuota objects
  repeated ResourceQuota items = 2;
}

// ResourceQuotaSpec defines the desired hard limits to enforce for Quota
message ResourceQuotaSpec {
  // Hard is the set of desired hard limits for each named resource
  map<string, k8s.io.kubernetes.pkg.api.resource.Quantity> hard = 1;
}

// ResourceQuotaStatus defines the enforced hard limits and observed use
message ResourceQuotaStatus {
  // Hard is the set of enforced hard limits for each named resource
  map<string, k8s.io.kubernetes.pkg.api.resource.Quantity> hard = 1;

  // Used is the current observed total usage of the resource in the namespace
  map<string, k8s.io.kubernetes.pkg.api.resource.Quantity> used = 2;
}

// ResourceRequirements describes the compute resource requirements.
message ResourceRequirements {
  // Limits describes the maximum amount of compute resources required.
  map<string, k8s.io.kubernetes.pkg.api.resource.Quantity> limits = 1;

  // Requests describes the minimum amount of compute resources required.
  // Note: 'Requests' are honored only for Persistent Volumes as of now.
  // TODO: Update the scheduler to use 'Requests' in addition to 'Limits'. If Request is omitted for a container,
  // it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value
  map<string, k8s.io.kubernetes.pkg.api.resource.Quantity> requests = 2;
}

// RunAsUserStrategyOptions defines the strategy type and any options used to create the strategy.
message RunAsUserStrategyOptions {
  // Type is the strategy that will dictate what RunAsUser is used in the SecurityContext.
  optional string type = 1;

  // UID is the user id that containers must run as.  Required for the MustRunAs strategy if not using
  // namespace/service account allocated uids.
  optional int64 uid = 2;

  // UIDRangeMin defines the min value for a strategy that allocates by range.
  optional int64 uidRangeMin = 3;

  // UIDRangeMax defines the max value for a strategy that allocates by range.
  optional int64 uidRangeMax = 4;
}

// SELinuxContextStrategyOptions defines the strategy type and any options used to create the strategy.
message SELinuxContextStrategyOptions {
  // Type is the strategy that will dictate what SELinux context is used in the SecurityContext.
  optional string type = 1;

  // seLinuxOptions required to run as; required for MustRunAs
  optional SELinuxOptions seLinuxOptions = 2;
}

// SELinuxOptions are the labels to be applied to the container.
message SELinuxOptions {
  // SELinux user label
  optional string user = 1;

  // SELinux role label
  optional string role = 2;

  // SELinux type label
  optional string type = 3;

  // SELinux level label.
  optional string level = 4;
}

// Secret holds secret data of a certain type.  The total bytes of the values in
// the Data field must be less than MaxSecretSize bytes.
message Secret {
  optional ObjectMeta metadata = 1;

  // Data contains the secret data.  Each key must be a valid DNS_SUBDOMAIN
  // or leading dot followed by valid DNS_SUBDOMAIN.
  // The serialized form of the secret data is a base64 encoded string,
  // representing the arbitrary (possibly non-string) data value here.
  map<string, bytes> data = 2;

  // Used to facilitate programmatic handling of secret data.
  optional string type = 3;
}

message SecretList {
  optional ListMeta metadata = 1;

  repeated Secret items = 2;
}

// SecretVolumeSource adapts a Secret into a VolumeSource
// 
// http://releases.k8s.io/v1.0.0/docs/design/secrets.md
message SecretVolumeSource {
  // Name of the secret in the pod's namespace to use
  optional string secretName = 1;
}

// SecurityContext holds security configuration that will be applied to a container.  SecurityContext
// contains duplication of some existing fields from the Container resource.  These duplicate fields
// will be populated based on the Container configuration if they are not set.  Defining them on
// both the Container AND the SecurityContext will result in an error.
message SecurityContext {
  // Capabilities are the capabilities to add/drop when running the container
  // Must match Container.Capabilities or be unset.  Will be defaulted to Container.Capabilities if left unset
  optional Capabilities capabilities = 1;

  // Run the container in privileged mode
  // Must match Container.Privileged or be unset.  Will be defaulted to Container.Privileged if left unset
  optional bool privileged = 2;

  // SELinuxOptions are the labels to be applied to the container
  // and volumes
  optional SELinuxOptions seLinuxOptions = 3;

  // RunAsUser is the UID to run the entrypoint of the container process.
  optional int64 runAsUser = 4;

  // RunAsNonRoot indicates that the container should be run as a non-root user.  If the RunAsUser
  // field is not explicitly set then the kubelet may check the image for a specified user or
  // perform defaulting to specify a user.
  optional bool runAsNonRoot = 5;
}

// SecurityContextConstraints governs the ability to make requests that affect the SecurityContext
// that will be applied to a container.
message SecurityContextConstraints {
  optional ObjectMeta metadata = 1;

  // Priority influences the sort order of SCCs when evaluating which SCCs to try first for
  // a given pod request based on access in the Users and Groups fields.  The higher the int, the
  // higher priority.  If scores for multiple SCCs are equal they will be sorted by name.
  optional int64 priority = 2;

  // AllowPrivilegedContainer determines if a container can request to be run as privileged.
  optional bool allowPrivilegedContainer = 3;

  // DefaultAddCapabilities is the default set of capabilities that will be added to the container
  // unless the pod spec specifically drops the capability.  You may not list a capabiility in both
  // DefaultAddCapabilities and RequiredDropCapabilities.
  repeated string defaultAddCapabilities = 4;

  // RequiredDropCapabilities are the capabilities that will be dropped from the container.  These
  // are required to be dropped and cannot be added.
  repeated string requiredDropCapabilities = 5;

  // AllowedCapabilities is a list of capabilities that can be requested to add to the container.
  // Capabilities in this field maybe added at the pod author's discretion.
  // You must not list a capability in both AllowedCapabilities and RequiredDropCapabilities.
  repeated string allowedCapabilities = 6;

  // AllowHostDirVolumePlugin determines if the policy allow containers to use the HostDir volume plugin
  optional bool allowHostDirVolumePlugin = 7;

  // AllowHostNetwork determines if the policy allows the use of HostNetwork in the pod spec.
  optional bool allowHostNetwork = 8;

  // AllowHostPorts determines if the policy allows host ports in the containers.
  optional bool allowHostPorts = 9;

  // AllowHostPID determines if the policy allows host pid in the containers.
  optional bool allowHostPID = 10;

  // AllowHostIPC determines if the policy allows host ipc in the containers.
  optional bool allowHostIPC = 11;

  // SELinuxContext is the strategy that will dictate what labels will be set in the SecurityContext.
  optional SELinuxContextStrategyOptions seLinuxContext = 12;

  // RunAsUser is the strategy that will dictate what RunAsUser is used in the SecurityContext.
  optional RunAsUserStrategyOptions runAsUser = 13;

  // SupplementalGroups is the strategy that will dictate what supplemental groups are used by the SecurityContext.
  optional SupplementalGroupsStrategyOptions supplementalGroups = 14;

  // FSGroup is the strategy that will dictate what fs group is used by the SecurityContext.
  optional FSGroupStrategyOptions fsGroup = 15;

  // ReadOnlyRootFilesystem when set to true will force containers to run with a read only root file
  // system.  If the container specifically requests to run with a non-read only root file system
  // the SCC should deny the pod.
  // If set to false the container may run with a read only root file system if it wishes but it
  // will not be forced to.
  optional bool readOnlyRootFilesystem = 16;

  // The users who have permissions to use this security context constraints
  repeated string users = 17;

  // The groups that have permission to use this security context constraints
  repeated string groups = 18;
}

// SecurityContextConstraintsList is a list of SecurityContextConstraints objects
message SecurityContextConstraintsList {
  optional ListMeta metadata = 1;

  repeated SecurityContextConstraints items = 2;
}

message SerializedReference {
  optional ObjectReference reference = 1;
}

// Service is a named abstraction of software service (for example, mysql) consisting of local port
// (for example 3306) that the proxy listens on, and the selector that determines which pods
// will answer requests sent through the proxy.
message Service {
  optional ObjectMeta metadata = 1;

  // Spec defines the behavior of a service.
  optional ServiceSpec spec = 2;

  // Status represents the current status of a service.
  optional ServiceStatus status = 3;
}

// ServiceAccount binds together:
// * a name, understood by users, and perhaps by peripheral systems, for an identity
// * a principal that can be authenticated and authorized
// * a set of secrets
message ServiceAccount {
  optional ObjectMeta metadata = 1;

  // Secrets is the list of secrets allowed to be used by pods running using this ServiceAccount
  repeated ObjectReference secrets = 2;

  // ImagePullSecrets is a list of references to secrets in the same namespace to use for pulling any images
  // in pods that reference this ServiceAccount.  ImagePullSecrets are distinct from Secrets because Secrets
  // can be mounted in the pod, but ImagePullSecrets are only accessed by the kubelet.
  repeated LocalObjectReference imagePullSecrets = 3;
}

// ServiceAccountList is a list of ServiceAccount objects
message ServiceAccountList {
  optional ListMeta metadata = 1;

  repeated ServiceAccount items = 2;
}

// ServiceList holds a list of services.
message ServiceList {
  optional ListMeta metadata = 1;

  repeated Service items = 2;
}

message ServicePort {
  // Optional if only one ServicePort is defined on this service: The
  // name of this port within the service.  This must be a DNS_LABEL.
  // All ports within a ServiceSpec must have unique names.  This maps to
  // the 'Name' field in EndpointPort objects.
  optional string name = 1;

  // Optional: The IP protocol for this port.  Supports "TCP" and "UDP",
  // default is TCP.
  optional string protocol = 2;

  // Required: The port that will be exposed by this service.
  optional int64 port = 3;

  // Optional: The target port on pods selected by this service.
  // If this is a string, it will be looked up as a named port in the
  // target Pod's container ports.  If this is not specified, the value
  // of Port is used (an identity map).
  optional k8s.io.kubernetes.pkg.util.intstr.IntOrString targetPort = 4;

  // The port on each node on which this service is exposed.
  // Default is to auto-allocate a port if the ServiceType of this Service requires one.
  optional int64 nodePort = 5;
}

// ServiceSpec describes the attributes that a user creates on a service
message ServiceSpec {
  // Required: The list of ports that are exposed by this service.
  repeated ServicePort ports = 1;

  // This service will route traffic to pods having labels matching this selector. If null, no endpoints will be automatically created. If empty, all pods will be selected.
  map<string, string> selector = 2;

  // PortalIP is usually assigned by the master.  If specified by the user
  // we will try to respect it or else fail the request.  This field can
  // not be changed by updates.
  // Valid values are None, empty string (""), or a valid IP address
  // None can be specified for headless services when proxying is not required
  optional string portalIP = 3;

  // CreateExternalLoadBalancer indicates whether a load balancer should be created for this service.
  optional bool createExternalLoadBalancer = 4;

  // Type determines how the service will be exposed.  Valid options: ClusterIP, NodePort, LoadBalancer
  optional string type = 5;

  // Deprecated. PublicIPs are used by external load balancers, or can be set by
  // users to handle external traffic that arrives at a node.
  repeated string publicIPs = 6;

  // Optional: Supports "ClientIP" and "None".  Used to maintain session affinity.
  optional string sessionAffinity = 7;

  // Only applies to Service Type: LoadBalancer
  // LoadBalancer will get created with the IP specified in this field.
  // This feature depends on whether the underlying cloud-provider supports specifying
  // the loadBalancerIP when a load balancer is created.
  // This field will be ignored if the cloud-provider does not support the feature.
  optional string loadBalancerIP = 8;
}

// ServiceStatus represents the current status of a service
message ServiceStatus {
  // LoadBalancer contains the current status of the load-balancer,
  // if one is present.
  optional LoadBalancerStatus loadBalancer = 1;
}

// SupplementalGroupsStrategyOptions defines the strategy type and options used to create the strategy.
message SupplementalGroupsStrategyOptions {
  // Type is the strategy that will dictate what supplemental groups is used in the SecurityContext.
  optional string type = 1;

  // Ranges are the allowed ranges of supplemental groups.  If you would like to force a single
  // supplemental group then supply a single range with the same start and end.
  repeated IDRange ranges = 2;
}

// TCPSocketAction describes an action based on opening a socket
message TCPSocketAction {
  // Required: Port to connect to.
  optional k8s.io.kubernetes.pkg.util.intstr.IntOrString port = 1;
}

// unversioned.TypeMeta describes an individual object in an API response or request
// with strings representing the type of the object and its API schema version.
// Structures that are versioned or persisted should inline unversioned.TypeMeta.
message TypeMeta {
  // Kind is a string value representing the REST resource this object represents.
  // Servers may infer this from the endpoint the client submits requests to.
  optional string kind = 1;

  // APIVersion defines the versioned schema of this representation of an object.
  // Servers should convert recognized schemas to the latest internal value, and
  // may reject unrecognized values.
  optional string apiVersion = 2;
}

// Volume represents a named volume in a pod that may be accessed by any containers in the pod.
message Volume {
  // Required: This must be a DNS_LABEL.  Each volume in a pod must have
  // a unique name.
  optional string name = 1;

  // Source represents the location and type of a volume to mount.
  // This is optional for now. If not specified, the Volume is implied to be an EmptyDir.
  // This implied behavior is deprecated and will be removed in a future version.
  optional VolumeSource volumeSource = 2;
}

// VolumeMount describes a mounting of a Volume within a container.
message VolumeMount {
  // Required: This must match the Name of a Volume [above].
  optional string name = 1;

  // Optional: Defaults to false (read-write).
  optional bool readOnly = 2;

  // Required.
  optional string mountPath = 3;
}

// VolumeSource represents the source location of a volume to mount.
// Only one of its members may be specified.
message VolumeSource {
  // HostPath represents a pre-existing file or directory on the host
  // machine that is directly exposed to the container. This is generally
  // used for system agents or other privileged things that are allowed
  // to see the host machine. Most containers will NOT need this.
  // TODO(jonesdl) We need to restrict who can use host directory mounts and who can/can not
  // mount host directories as read/write.
  optional HostPathVolumeSource hostPath = 1;

  // EmptyDir represents a temporary directory that shares a pod's lifetime.
  optional EmptyDirVolumeSource emptyDir = 2;

  // GCEPersistentDisk represents a GCE Disk resource that is attached to a
  // kubelet's host machine and then exposed to the pod.
  optional GCEPersistentDiskVolumeSource gcePersistentDisk = 3;

  // AWSElasticBlockStore represents an AWS Disk resource that is attached to a
  // kubelet's host machine and then exposed to the pod.
  optional AWSElasticBlockStoreVolumeSource awsElasticBlockStore = 4;

  // GitRepo represents a git repository at a particular revision.
  optional GitRepoVolumeSource gitRepo = 5;

  // Secret represents a secret that should populate this volume.
  optional SecretVolumeSource secret = 6;

  // NFS represents an NFS mount on the host that shares a pod's lifetime
  optional NFSVolumeSource nfs = 7;

  // ISCSI represents an ISCSI Disk resource that is attached to a
  // kubelet's host machine and then exposed to the pod.
  optional ISCSIVolumeSource iscsi = 8;

  // Glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime
  optional GlusterfsVolumeSource glusterfs = 9;

  // PersistentVolumeClaimVolumeSource represents a reference to a PersistentVolumeClaim in the same namespace
  optional PersistentVolumeClaimVolumeSource persistentVolumeClaim = 10;

  // RBD represents a Rados Block Device mount on the host that shares a pod's lifetime
  optional RBDVolumeSource rbd = 11;

  // Cinder represents a cinder volume attached and mounted on kubelets host machine
  // More info: http://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md
  optional CinderVolumeSource cinder = 12;

  // CephFS represents a Ceph FS mount on the host that shares a pod's lifetime
  optional CephFSVolumeSource cephfs = 13;

  // Flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running
  optional FlockerVolumeSource flocker = 14;

  // DownwardAPI represents metadata about the pod that should populate this volume
  optional DownwardAPIVolumeSource downwardAPI = 15;

  // FC represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
  optional FCVolumeSource fc = 16;

  // Metadata represents metadata about the pod that should populate this volume
  // NOTE: Deprecated in favor of DownwardAPI
  optional MetadataVolumeSource metadata = 17;
}

